/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Plugin Integration Tests Root Project
 *
 * This project orchestrates all integration tests that demonstrate real usage patterns
 * of the gradle-docker plugin including:
 * - Docker operations (build, tag, save, publish) in docker/ subproject
 * - Docker Compose orchestration in dockerTest/ subproject
 * - Application JAR building in app/ subproject (shared dependency)
 *
 * Each major subproject represents a category of integration tests.
 */

// No plugins needed at root level - subprojects handle their own builds

group = 'com.kineticfire.gradle.docker.integration'
version = '1.0.0'

// Aggregate task to run all integration tests
//   - Probably want to run 'cleanAll' before invoking this task
tasks.register('integrationTest') {
    description = 'Run all integration tests (Docker, DockerOrch, DockerWorkflows, and DockerProject)'
    group = 'verification'

    // Ensure app is built first, then run all integration test categories
    dependsOn ':app:build'
    dependsOn ':docker:integrationTest'
    dependsOn ':dockerTest:integrationTest'
    dependsOn ':dockerWorkflows:integrationTest'
    dependsOn ':dockerProject:integrationTest'
}

// Task to run only docker integration tests
tasks.register('dockerIntegrationTest') {
    description = 'Run docker integration tests only'
    group = 'verification'

    dependsOn ':app:build'
    dependsOn ':docker:integrationTest'
}

// Task to run only dockerTest integration tests
tasks.register('dockerTestIntegrationTest') {
    description = 'Run dockerTest integration tests only'
    group = 'verification'

    dependsOn ':app:build'
    dependsOn ':dockerTest:integrationTest'
}

// Task to run only dockerWorkflows integration tests
tasks.register('dockerWorkflowsIntegrationTest') {
    description = 'Run dockerWorkflows integration tests only'
    group = 'verification'

    dependsOn ':app:build'
    dependsOn ':dockerWorkflows:integrationTest'
}

// Task to run only dockerProject integration tests
tasks.register('dockerProjectIntegrationTest') {
    description = 'Run dockerProject integration tests only'
    group = 'verification'

    dependsOn ':app:build'
    dependsOn ':dockerProject:integrationTest'
}

// Aggregate cleanup task
tasks.register('cleanAll') {
    description = 'Clean all integration test projects'
    group = 'build'

    dependsOn ':app:clean'
    dependsOn ':docker:cleanAll'
    dependsOn ':dockerTest:clean'
    dependsOn ':dockerWorkflows:cleanAll'
    dependsOn ':dockerProject:cleanAll'
}

// Docker container verification task
// Verifies that no test registry containers remain after integration tests
// This is a critical requirement per CLAUDE.md acceptance criteria
abstract class VerifyNoContainersTask extends DefaultTask {
    @javax.inject.Inject
    abstract ExecOperations getExecOps()

    @TaskAction
    void verify() {
        def stdout = new ByteArrayOutputStream()

        def result = execOps.exec {
            commandLine 'docker', 'ps', '-a', '--filter', 'name=test-registry-', '--format', '{{.Names}}'
            standardOutput = stdout
            ignoreExitValue = true
        }

        def containers = stdout.toString().trim()

        if (containers && !containers.isEmpty()) {
            def containerList = containers.split('\n')
            def message = """
                |
                |❌ FAILURE: Lingering test containers found
                |
                |Found ${containerList.length} test registry container(s) that were not cleaned up:
                |${containerList.collect { "  - ${it}" }.join('\n')}
                |
                |Per CLAUDE.md acceptance criteria:
                |  "No lingering containers may remain."
                |  "Do not declare success until docker ps -a shows no containers."
                |
                |To clean up manually: docker rm -f \$(docker ps -a --filter name=test-registry- -q)
                |
                """.stripMargin()
            throw new GradleException(message)
        } else {
            logger.lifecycle("✓ No lingering Docker containers found")
        }
    }
}

tasks.register('verifyNoContainers', VerifyNoContainersTask) {
    description = 'Verify no Docker test containers remain'
    group = 'verification'
}

// Global cleanup task - force remove any lingering test containers
// This task should be run after integration tests to ensure cleanup
abstract class CleanupContainersTask extends DefaultTask {
    @javax.inject.Inject
    abstract ExecOperations getExecOps()

    @TaskAction
    void cleanup() {
        logger.lifecycle("Performing Docker container cleanup...")

        execOps.exec {
            commandLine 'sh', '-c',
                'docker ps -a --filter name=test-registry- -q | xargs -r docker rm -f || true'
            ignoreExitValue = true
        }

        logger.lifecycle("✓ Cleanup complete")
    }
}

tasks.register('cleanupContainers', CleanupContainersTask) {
    description = 'Force cleanup of all test registry containers'
    group = 'build'
}

// Make integrationTest always clean up containers afterward, then verify
tasks.named('integrationTest').configure {
    finalizedBy('cleanupContainers')
}

tasks.named('cleanupContainers').configure {
    finalizedBy('verifyNoContainers')
}

