/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * dockerWorkflows Integration Test: Scenario 1 - Basic Workflow
 *
 * This scenario demonstrates the basic dockerWorkflows DSL usage for a simple
 * build → test → add success tag workflow.
 *
 * What this tests:
 * - Pipeline definition with build, test, and onTestSuccess steps
 * - Automatic orchestration of dockerBuild*, composeUp*, integrationTest, composeDown*
 * - Application of success tags when tests pass
 *
 * Port allocation (per README conventions):
 * - Registry: N/A (no publish in this basic scenario)
 * - Service: 9200 (workflow scenario 1)
 */

plugins {
    id 'groovy'
    id 'com.kineticfire.gradle.docker'
}

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    testImplementation libs.groovy.all
    testImplementation libs.spock.core
    testRuntimeOnly libs.junit.platform.launcher
}

// Get JAR file from the shared app subproject
def jarFileProvider = project(':app').tasks.named('jar').flatMap { it.archiveFile }
def jarFileNameProvider = jarFileProvider.map { it.asFile.name }

// =============================================================================
// DOCKER DSL: Define the image to build
// =============================================================================
docker {
    images {
        // The image name must be unique across integration tests
        workflowBasicApp {
            imageName = 'workflow-scenario1-app'
            tags = ['latest', '1.0.0']

            // Build context task prepares files for Docker build
            contextTask = tasks.register('prepareWorkflowAppContext', Copy) {
                group = 'docker'
                description = 'Prepare Docker build context for workflow test app'
                into layout.buildDirectory.dir('docker-context/workflowBasicApp')
                from('src/main/docker')

                // Copy JAR from shared app project
                from(jarFileProvider) {
                    rename { 'app.jar' }
                }

                dependsOn project(':app').tasks.named('jar')
            }
        }
    }
}

// =============================================================================
// DOCKER ORCH DSL: Define the compose stack for testing
// =============================================================================
dockerTest {
    composeStacks {
        workflowTest {
            files.from('src/integrationTest/resources/compose/workflow-app.yml')
            projectName = "workflow-scenario1-test"

            waitForHealthy {
                waitForServices.set(['app'])
                timeoutSeconds.set(60)
                pollSeconds.set(2)
            }
        }
    }
}

// =============================================================================
// DOCKER WORKFLOWS DSL: Define the pipeline
// =============================================================================
dockerWorkflows {
    pipelines {
        // Basic CI pipeline: build → test → tag as 'tested' on success
        basicPipeline {
            description = 'Basic CI pipeline demonstrating build, test, and success tag'

            // Build step: build the workflowBasicApp image
            build {
                image = docker.images.workflowBasicApp
            }

            // Test step: run integration tests against the containerized app
            test {
                stack = dockerTest.composeStacks.workflowTest
                testTaskName = 'integrationTest'
            }

            // On test success: add 'tested' tag to the image
            onTestSuccess {
                additionalTags = ['tested']
            }
        }
    }
}

// =============================================================================
// Integration Test Configuration
// =============================================================================
// Plugin automatically creates integrationTest source set when composeStacks configured

dependencies {
    integrationTestImplementation files("${rootProject.projectDir}/buildSrc/build/classes/groovy/main")
    integrationTestImplementation libs.rest.assured
    integrationTestImplementation libs.rest.assured.json.path
}

// Configure integration test task
tasks.named('integrationTest') {
    // Pass compose state info to tests
    systemProperty 'COMPOSE_STATE_FILE',
        layout.buildDirectory.file('compose-state/workflowTest-state.json').get().asFile.absolutePath
    systemProperty 'COMPOSE_PROJECT_NAME', "workflow-scenario1-test"
    systemProperty 'IMAGE_NAME', 'workflow-scenario1-app'
}

// =============================================================================
// Task Orchestration
// =============================================================================
// Ensure image is built before compose up
afterEvaluate {
    tasks.named('composeUpWorkflowTest') {
        dependsOn tasks.named('dockerBuildWorkflowBasicApp')
    }

    // The normal integration test flow (used directly, not via pipeline)
    tasks.named('integrationTest') {
        dependsOn tasks.named('composeUpWorkflowTest')
        finalizedBy tasks.named('composeDownWorkflowTest')
    }
}

// =============================================================================
// Verification Task: Run the full pipeline and verify results
// =============================================================================
tasks.register('runWorkflowIntegrationTest') {
    description = 'Run the dockerWorkflows pipeline and verify results'
    group = 'verification'

    // Ensure JAR is built first
    dependsOn project(':app').tasks.named('jar')

    // Run the pipeline
    dependsOn tasks.named('runBasicPipeline')

    doLast {
        // Verify the 'tested' tag was applied
        def result = exec {
            commandLine 'docker', 'images', '-q', 'workflow-scenario1-app:tested'
            standardOutput = new ByteArrayOutputStream()
            ignoreExitValue = true
        }
        def imageId = result.standardOutput.toString().trim()
        if (imageId.isEmpty()) {
            throw new GradleException("Expected image 'workflow-scenario1-app:tested' not found! " +
                "The onTestSuccess additionalTags may not have been applied.")
        }
        logger.lifecycle("SUCCESS: Image 'workflow-scenario1-app:tested' found with ID: ${imageId}")
    }
}

// Cleanup task
tasks.register('cleanupWorkflow') {
    description = 'Clean up Docker resources from workflow test'
    group = 'verification'

    doLast {
        // Remove test containers
        exec {
            commandLine 'docker', 'compose', '-p', 'workflow-scenario1-test', 'down', '-v'
            ignoreExitValue = true
        }

        // Remove test images
        ['latest', '1.0.0', 'tested'].each { tag ->
            exec {
                commandLine 'docker', 'rmi', "workflow-scenario1-app:${tag}"
                ignoreExitValue = true
            }
        }
    }
}
