/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * App-Image subproject - builds Docker image and runs integration tests.
 * 
 * This demonstrates how developers would use the gradle-docker plugin to:
 * - Build Docker images using the docker {} DSL (UC-6)  
 * - Test images using Docker Compose orchestration with dockerOrch {} DSL (UC-7)
 * - Use different lifecycle patterns (suite, class, method)
 * 
 * This subproject showcases realistic usage patterns developers would follow.
 */

plugins {
    id 'groovy'
    id 'java'
    id 'com.kineticfire.gradle.gradle-docker' version '1.0.0'
}

group = 'com.kineticfire.gradle.docker.integration'
version = '1.0.0'

repositories {
    mavenCentral()
}

// Configure source sets for testing
sourceSets {
    functionalTest {
        groovy.srcDir 'src/functionalTest/groovy'
        resources.srcDir 'src/functionalTest/resources'
        compileClasspath += sourceSets.main.output
        runtimeClasspath += output + compileClasspath
    }
    integrationTest {
        java.srcDir 'src/integrationTest/java'
        groovy.srcDir 'src/integrationTest/groovy'
        resources.srcDir 'src/integrationTest/resources'  
        compileClasspath += sourceSets.main.output
        runtimeClasspath += output + compileClasspath
    }
}

// Configure test configurations
configurations {
    functionalTestImplementation.extendsFrom implementation
    functionalTestRuntimeOnly.extendsFrom runtimeOnly
    integrationTestImplementation.extendsFrom implementation
    integrationTestRuntimeOnly.extendsFrom runtimeOnly
}

// Handle duplicate resources
tasks.withType(ProcessResources) {
    duplicatesStrategy = DuplicatesStrategy.WARN
}

dependencies {
    // Functional Test dependencies (Groovy/Spock)
    functionalTestImplementation platform('org.spockframework:spock-bom:2.4-M4-groovy-4.0')
    functionalTestImplementation 'org.spockframework:spock-core'
    functionalTestImplementation 'org.spockframework:spock-junit4'
    functionalTestImplementation 'com.fasterxml.jackson.core:jackson-databind:2.16.0'
    functionalTestRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    functionalTestRuntimeOnly 'org.junit.vintage:junit-vintage-engine'
    
    // Integration Test dependencies (Java/JUnit)  
    integrationTestImplementation platform('org.junit:junit-bom:5.10.0')
    integrationTestImplementation 'org.junit.jupiter:junit-jupiter'
    integrationTestImplementation 'org.assertj:assertj-core:3.24.2'
    integrationTestImplementation 'com.fasterxml.jackson.core:jackson-databind:2.16.0'
    integrationTestImplementation gradleTestKit()
    integrationTestRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    
    // Integration Test dependencies (Groovy/Spock for registry tests)
    integrationTestImplementation platform('org.spockframework:spock-bom:2.4-M4-groovy-4.0')
    integrationTestImplementation 'org.spockframework:spock-core'
    integrationTestImplementation 'org.spockframework:spock-junit4'
}

// DEMONSTRATING UC-6: Project Developer Create and Publish Docker Image
docker {
    images {
        timeServer {
            context = file('src/main/docker')
            dockerfile = file('src/main/docker/Dockerfile') 
            tags = [
                "time-server:${version}",
                "time-server:latest"
            ]
            buildArgs = [
                'JAR_FILE': "app-${version}.jar",
                'BUILD_VERSION': version,
                'BUILD_TIME': new Date().format('yyyy-MM-dd HH:mm:ss')
            ]
        }
    }
}

// DEMONSTRATING UC-7: Project Developer Compose Orchestration  
dockerOrch {
    composeStacks {
        smokeTest {
            files.from('src/functionalTest/resources/compose/smoke-test.yml')
            projectName = "smoke-${project.name}"
            waitForHealthy {
                services = ["time-server"]
                timeoutSeconds = 30
            }
            logs {
                writeTo = file("$buildDir/compose-logs/smokeTest")
                tailLines = 100
            }
        }
        integrationSuite {
            files.from('src/integrationTest/resources/compose/integration-suite.yml')
            projectName = "integration-suite-${project.name}"
            waitForHealthy {
                services = ["time-server"]
                timeoutSeconds = 30  
            }
            logs {
                writeTo = file("$buildDir/compose-logs/integrationSuite")
                tailLines = 200
            }
        }
        integrationClass {
            files.from('src/integrationTest/resources/compose/integration-class.yml')
            projectName = "integration-class-${project.name}"
            waitForHealthy {
                services = ["time-server"]
                timeoutSeconds = 45
            }
            logs {
                writeTo = file("$buildDir/compose-logs/integrationClass") 
                tailLines = 200
            }
        }
        integrationMethod {
            files.from('src/integrationTest/resources/compose/integration-method.yml')
            projectName = "integration-method-${project.name}"
            waitForHealthy {
                services = ["time-server"] 
                timeoutSeconds = 20
            }
            logs {
                writeTo = file("$buildDir/compose-logs/integrationMethod")
                tailLines = 100
            }
        }
    }
}

// Copy the app JAR to Docker context before building image
tasks.register('copyAppJar', Copy) {
    description = 'Copy app JAR to Docker build context'
    from project(':app').tasks.jar.outputs.files
    into 'src/main/docker'
    rename { "app-${version}.jar" }
}

// Ensure JAR is copied before Docker build
afterEvaluate {
    tasks.named('dockerBuildTimeServer') {
        dependsOn 'copyAppJar'
        dependsOn ':app:jar'
    }
}

// SMOKE TESTS: Quick validation using suite lifecycle (fastest)
tasks.register('smokeTest', Test) {
    description = 'Smoke tests with suite lifecycle - quick Docker image validation'
    group = 'verification'
    testClassesDirs = sourceSets.functionalTest.output.classesDirs  
    classpath = sourceSets.functionalTest.runtimeClasspath
    useJUnitPlatform()
    
    // DEMONSTRATE: Suite lifecycle - compose up once for all tests (fastest)
    usesCompose stack: "smokeTest", lifecycle: "suite" 
    systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("smokeTest")
    
    dependsOn 'dockerBuildTimeServer'
}

// INTEGRATION TESTS: Demonstrating different lifecycle patterns

tasks.register('integrationTestSuite', Test) {
    description = 'Integration tests with suite lifecycle - shared environment for performance'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    useJUnitPlatform()
    include '**/TimeServerSuiteLifecycleIT.class'
    
    // DEMONSTRATE: Suite lifecycle - one compose up/down per test suite
    usesCompose stack: "integrationSuite", lifecycle: "suite"
    systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("integrationSuite")
    
    dependsOn 'dockerBuildTimeServer'
    shouldRunAfter 'smokeTest'
}

tasks.register('integrationTestClass', Test) {
    description = 'Integration tests with class lifecycle - fresh environment per test class'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    useJUnitPlatform()
    include '**/TimeServerClassLifecycleIT.class'
    
    // DEMONSTRATE: Class lifecycle - compose up/down per test class  
    // TODO: usesCompose functionality not yet implemented in plugin
    // usesCompose stack: "integrationClass", lifecycle: "class"
    // systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("integrationClass")
    
    dependsOn 'dockerBuildTimeServer'
    shouldRunAfter 'integrationTestSuite'
}

tasks.register('integrationTestMethod', Test) {
    description = 'Integration tests with method lifecycle - maximum isolation (slowest)'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    useJUnitPlatform()
    include '**/TimeServerMethodLifecycleIT.class'
    
    // DEMONSTRATE: Method lifecycle - compose up/down per test method (maximum isolation)
    // TODO: usesCompose functionality not yet implemented in plugin
    // usesCompose stack: "integrationMethod", lifecycle: "method"
    // systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("integrationMethod")
    
    dependsOn 'dockerBuildTimeServer'
    shouldRunAfter 'integrationTestClass'
}

tasks.register('integrationTestRegistry', Test) {
    description = 'Integration tests for Docker registry publishing functionality'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    useJUnitPlatform()
    include '**/DockerRegistryPublishIntegrationIT.class'
    
    dependsOn 'dockerBuildTimeServer'
    shouldRunAfter 'integrationTestMethod'
}