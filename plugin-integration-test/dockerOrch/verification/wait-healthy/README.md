# Verification Test: Wait-Healthy with Custom Timeout and Poll Configuration

**Type**: Plugin Mechanics Validation
**Lifecycle**: CLASS (setupSpec/cleanupSpec)
**Purpose**: Validates wait-healthy functionality with custom timeout/poll settings

## What This Test Validates

This verification test ensures the dockerOrch plugin correctly:
- ✅ Waits for containers to become HEALTHY with custom timeout settings (90 seconds)
- ✅ Respects custom poll interval settings (1 second)
- ✅ Handles applications with startup delays (5000ms delay configured)
- ✅ Verifies container uptime matches expected startup delay
- ✅ Generates state files with correct structure and data
- ✅ Maps ports correctly (container → host)
- ✅ Stops Docker Compose stacks with `composeDown`
- ✅ Cleans up all containers, networks, and volumes

## Test Lifecycle

**Lifecycle Type**: `CLASS`

The test uses Spock's `setupSpec()` and `cleanupSpec()` methods:
- `setupSpec()` - Runs once before all tests in the class (reads state file)
- `cleanupSpec()` - Runs once after all tests in the class (verifies cleanup)
- Tests run with the same Docker Compose stack (started by `composeUpWaitHealthyTest` task)

This mirrors how real users would test: start containers once, run multiple tests, tear down once.

## Test Configuration

### Application Startup
- **Startup Delay**: 5000ms (5 seconds) - Simulated via `STARTUP_DELAY_MS` environment variable
- **Purpose**: Tests that the plugin waits appropriately for slow-starting applications

### Health Check Configuration
- **Health Check Interval**: 3 seconds (Docker Compose healthcheck interval)
- **Health Check Timeout**: 2 seconds (Docker Compose healthcheck timeout)
- **Health Check Retries**: 15 (Docker Compose healthcheck retries)
- **Start Period**: 15 seconds (Docker Compose healthcheck start_period)

### Wait-Healthy Configuration
- **Timeout**: 90 seconds (custom - longer than basic test's 60 seconds)
- **Poll Interval**: 1 second (custom - faster than basic test's 2 seconds)
- **Services**: `wait-healthy-app`

## Running Tests

**⚠️ Important**: All commands must be run from `plugin-integration-test/` directory.

### Full Integration Test Workflow

```bash
# From plugin-integration-test/ directory
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:verification:wait-healthy:app-image:runIntegrationTest
```

This runs:
1. Build app JAR (with startup delay simulation)
2. Build Docker image
3. Start Docker Compose stack (`composeUpWaitHealthyTest`)
4. Wait for container to be HEALTHY (up to 90 seconds, polling every 1 second)
5. Run integration tests (validates timing and configuration)
6. Stop Docker Compose stack (`composeDownWaitHealthyTest`)

### Individual Tasks

```bash
# Clean build artifacts
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:verification:wait-healthy:clean

# Build the app
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:verification:wait-healthy:app:bootJar

# Build Docker image
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:verification:wait-healthy:app-image:dockerBuildWaitHealthyApp

# Start Docker Compose stack
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:verification:wait-healthy:app-image:composeUpWaitHealthyTest

# Run tests (requires stack to be up)
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:verification:wait-healthy:app-image:integrationTest

# Stop Docker Compose stack
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:verification:wait-healthy:app-image:composeDownWaitHealthyTest
```

### Clean Everything

```bash
# Clean build artifacts and Docker images
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:verification:wait-healthy:clean \
  dockerOrch:verification:wait-healthy:app:clean \
  dockerOrch:verification:wait-healthy:app-image:clean
```

## Test Structure

```groovy
class WaitHealthyPluginIT extends Specification {

    static String projectName
    static Map stateData

    def setupSpec() {
        // Runs ONCE before all tests
        // Reads state file generated by composeUp
        projectName = System.getProperty('COMPOSE_PROJECT_NAME')
        stateData = StateFileValidator.parseStateFile(stateFile)
    }

    def "plugin should generate valid state file"() { ... }
    def "plugin should start container in running state"() { ... }
    def "plugin should wait until container is healthy"() { ... }
    def "plugin should wait correct amount of time before healthy"() { ... }
    def "plugin should respect timeout configuration"() { ... }
    def "plugin should respect poll interval"() { ... }
    def "plugin should map ports correctly"() { ... }

    def cleanupSpec() {
        // Runs ONCE after all tests
        // Verifies no resource leaks
        CleanupValidator.verifyCleanup(projectName)
    }
}
```

## Tests Performed

### 1. State File Validation
Validates that the state file:
- Has correct structure (stackName, projectName, timestamp, services)
- Contains `wait-healthy-app` service
- Has port mapping information

### 2. Container Running State
Validates that the container is in RUNNING state using `docker ps`.

### 3. Container Healthy State
Validates that the container is HEALTHY using Docker's health check status.

### 4. Startup Delay Validation
Validates that:
- The application actually waited for the configured startup delay (5000ms)
- The health endpoint reports uptime >= 5000ms
- This proves the plugin waited appropriately for the slow-starting application

### 5. Timeout Configuration
Validates that:
- The 90-second timeout was respected
- The container became healthy within the timeout window
- This is tested implicitly - if the timeout was too short, composeUp would have failed

### 6. Poll Interval Configuration
Validates that:
- The 1-second poll interval was used
- The plugin polled multiple times before success
- This is tested implicitly by the successful health status

### 7. Port Mapping
Validates that:
- Ports are mapped correctly from container (8080) to host
- State file contains accurate port mapping information

## Validation Tools Used

This test uses internal validators from `buildSrc/`:

- **`StateFileValidator`** - Validates state file structure and content
  - `parseStateFile()` - Parse JSON state file
  - `assertValidStructure()` - Check required fields
  - `getPublishedPort()` - Extract port mappings
  - `getServiceInfo()` - Get service details

- **`DockerComposeValidator`** - Validates Docker Compose state
  - `isContainerRunning()` - Check container is running
  - `isContainerHealthy()` - Check container health status

- **`CleanupValidator`** - Ensures no resource leaks
  - `verifyCleanup()` - Assert no containers/networks remain
  - `forceCleanup()` - Force removal if verification fails

## Expected Results

All 7 tests should pass:
- ✅ State file has valid structure with all required fields
- ✅ Container is in RUNNING state
- ✅ Container is HEALTHY (health check passed)
- ✅ Container uptime shows it waited >= 5000ms (startup delay)
- ✅ Timeout configuration (90 seconds) was respected
- ✅ Poll interval (1 second) was respected
- ✅ Port mapping is correct (state file matches Docker)

No containers should remain after tests complete.

## Differences from Basic Verification Test

This test differs from the `basic` verification test in the following ways:

| Aspect | Basic Test | Wait-Healthy Test |
|--------|-----------|------------------|
| **Startup Delay** | None | 5000ms (5 seconds) |
| **Timeout** | 60 seconds | 90 seconds |
| **Poll Interval** | 2 seconds | 1 second |
| **Health Check Interval** | 5s | 3s |
| **Health Check Retries** | 5 | 15 |
| **Start Period** | 10s | 15s |
| **Timing Tests** | No | Yes - validates uptime |
| **Configuration Tests** | No | Yes - validates timeout/poll |

## Troubleshooting

**Tests fail with "container not found"**:
- Ensure `composeUpWaitHealthyTest` ran successfully before `integrationTest`
- Use `runIntegrationTest` task which handles dependencies automatically

**Tests fail with "state file not found"**:
- State file is at `build/compose-state/waitHealthyTest-state.json`
- Ensure `composeUpWaitHealthyTest` completed successfully

**Tests fail with "uptime too low"**:
- Check that STARTUP_DELAY_MS environment variable is set in compose file
- Verify the application actually delayed startup
- Check container logs: `docker logs <container-id>`

**Cleanup verification fails**:
- Run manual cleanup: `docker ps -a -q --filter "name=verification-wait-healthy" | xargs -r docker rm -f`
- Check for lingering networks: `docker network ls | grep verification-wait-healthy`

**Timeout occurs during composeUp**:
- Check if 90 second timeout is sufficient for your environment
- Verify health check is configured correctly in compose file
- Check container logs for startup errors

**Port already in use**:
- Docker Compose uses random host ports to avoid conflicts
- Check actual port in state file

## ⚠️ This is NOT a User Example

This test validates plugin mechanics using internal tools. For user-facing examples of how to test applications, see `../../examples/web-app/README.md`.
