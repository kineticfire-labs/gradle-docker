# Example: Testing a Web Application with Docker Compose

**Type**: User-Facing Example
**Lifecycle**: CLASS (setupSpec/cleanupSpec)
**Use Case**: REST API testing with dockerOrch plugin

## Purpose

This example demonstrates how to test a Spring Boot REST API using the dockerOrch plugin. It shows:

- ‚úÖ How to configure Docker Compose orchestration
- ‚úÖ How to wait for containers to be healthy
- ‚úÖ How to read port mappings from state files
- ‚úÖ How to test REST endpoints with RestAssured
- ‚úÖ How to test concurrent request handling

**üìã Copy and adapt this for your own projects!**

## Test Lifecycle

**Lifecycle Type**: `CLASS`

The test uses Spock's `setupSpec()` method:
- `setupSpec()` - Runs once before all tests
  - Reads state file generated by `composeUp`
  - Extracts published port for isolated-tests service
  - Configures RestAssured base URL
- Tests run with the same Docker Compose stack
- No `cleanupSpec()` needed (composeDown handles cleanup)

**Why CLASS lifecycle?**
- Containers start once, tests run multiple times (efficient)
- Mirrors real-world usage: start environment, run test suite, tear down
- Reduces test execution time (no container restarts between tests)

## Running Tests

**‚ö†Ô∏è Important**: All commands must be run from `plugin-integration-test/` directory.

### Quick Start

```bash
# From plugin-integration-test/ directory
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:examples:isolated-tests:app-image:runIntegrationTest
```

This runs the complete workflow:
1. Build app JAR (`bootJar`)
2. Build Docker image (`dockerBuildIsolatedTests`)
3. Start Docker Compose (`composeUpIsolatedTestsTest`)
4. Wait for container to be HEALTHY
5. Run integration tests (`integrationTest`)
6. Stop Docker Compose (`composeDownIsolatedTestsTest`)

### Individual Tasks

```bash
# Clean build artifacts
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:examples:isolated-tests:clean

# Build the Spring Boot app
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:examples:isolated-tests:app:bootJar

# Build Docker image
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:examples:isolated-tests:app-image:dockerBuildIsolatedTests

# Start Docker Compose stack
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:examples:isolated-tests:app-image:composeUpIsolatedTestsTest

# Run tests (requires stack to be up)
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:examples:isolated-tests:app-image:integrationTest

# Stop Docker Compose stack
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:examples:isolated-tests:app-image:composeDownIsolatedTestsTest
```

### Clean Everything

```bash
# Clean all build artifacts and Docker images
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerOrch:examples:isolated-tests:clean \
  dockerOrch:examples:isolated-tests:app:clean \
  dockerOrch:examples:isolated-tests:app-image:clean
```

## Plugin Configuration

### build.gradle (dockerOrch DSL)

```groovy
dockerOrch {
    composeStacks {
        isolatedTestsTest {
            // Compose file location
            files.from('src/integrationTest/resources/compose/isolated-tests.yml')

            // Docker Compose project name (must be unique)
            projectName = "example-isolated-tests-test"

            // Wait for app to be healthy before running tests
            waitForHealthy {
                waitForServices.set(['isolated-tests'])
                timeoutSeconds.set(60)
                pollSeconds.set(2)
            }
        }
    }
}
```

**Key Configuration Points:**
- `files.from()` - Path to Docker Compose file
- `projectName` - Unique name for this stack (prevents conflicts)
- `waitForHealthy` - Block until container health check passes
- `waitForServices` - List of services to wait for
- `timeoutSeconds` - Maximum time to wait (60s)
- `pollSeconds` - How often to check status (2s)

### Docker Compose File

```yaml
# src/integrationTest/resources/compose/isolated-tests.yml
services:
  isolated-tests:
    image: example-isolated-tests:latest
    ports:
      - "8080"  # Random host port assigned
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 10s
```

**Important Notes:**
- Don't include `version:` (deprecated)
- Use random host ports (`"8080"`) to avoid conflicts
- Include health check for `waitForHealthy` to work
- `start_period` gives app time to initialize

## Test Structure

### Reading Port Mapping

```groovy
class IsolatedTestsExampleIT extends Specification {

    static String baseUrl

    def setupSpec() {
        // Read state file generated by dockerOrch plugin
        def stateFilePath = System.getProperty('COMPOSE_STATE_FILE')
        def stateFile = new File(stateFilePath)
        def stateData = new JsonSlurper().parse(stateFile)

        // Extract published port (Docker assigns random port)
        def port = stateData.services['isolated-tests'].publishedPorts[0].host

        // Configure test base URL
        baseUrl = "http://localhost:${port}"
        RestAssured.baseURI = baseUrl
    }

    // Tests go here...
}
```

**Why read from state file?**
- Docker Compose assigns random host ports to avoid conflicts
- State file contains actual port mapping
- Plugin generates state file automatically during `composeUp`

### Testing REST Endpoints

```groovy
def "should respond to health check endpoint"() {
    when: "we call the /health endpoint"
    def response = given()
        .get("/health")

    then: "we get 200 OK"
    response.statusCode() == 200

    and: "response indicates app is UP"
    response.jsonPath().getString("status") == "UP"
}

def "should return app information from root endpoint"() {
    when: "we call the root endpoint"
    def response = given()
        .get("/")

    then: "we get 200 OK"
    response.statusCode() == 200

    and: "response contains app information"
    response.jsonPath().getString("message") == "Web App is running"
    response.jsonPath().getString("version") == "1.0.0"
}
```

**RestAssured Benefits:**
- Fluent API for REST testing
- Built-in JSON path support
- Standard tool in Java ecosystem
- Easy to read and maintain

### Testing Concurrent Requests

```groovy
def "should handle multiple concurrent requests successfully"() {
    given: "we want to test concurrent load"
    def concurrentRequests = 50

    when: "we make many concurrent requests"
    def results = (1..concurrentRequests).collect {
        Thread.start {
            given()
                .get("/health")
                .statusCode()
        }
    }*.join()

    then: "all requests should succeed"
    results.size() == concurrentRequests
    results.every { it == 200 }
}
```

## Application Code

### Spring Boot Application

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### REST Controller

```java
@RestController
public class HealthController {

    @GetMapping("/health")
    public Map<String, Object> health() {
        return Map.of(
            "status", "UP",
            "timestamp", System.currentTimeMillis()
        );
    }

    @GetMapping("/")
    public Map<String, String> root() {
        return Map.of(
            "message", "Web App is running",
            "version", "1.0.0"
        );
    }
}
```

## Dependencies

```groovy
dependencies {
    // Spring Boot
    implementation 'org.springframework.boot:spring-boot-starter-web'

    // Testing
    testImplementation 'org.spockframework:spock-core'
    integrationTestImplementation 'io.rest-assured:rest-assured:5.3.0'
    integrationTestImplementation 'io.rest-assured:json-path:5.3.0'
}
```

**RestAssured** is added as `integrationTestImplementation` (not used in unit tests).

## Expected Results

All 5 tests should pass:
- ‚úÖ Health check endpoint returns 200 OK with "UP" status
- ‚úÖ Root endpoint returns app information
- ‚úÖ 50 concurrent requests all succeed
- ‚úÖ Content type is JSON
- ‚úÖ Response time is under 1 second

## Adapting for Your Project

### 1. Copy Directory Structure

```
your-project/
‚îú‚îÄ‚îÄ app/                      # Your application
‚îÇ   ‚îú‚îÄ‚îÄ src/main/java/       # Application code
‚îÇ   ‚îî‚îÄ‚îÄ build.gradle         # App build config
‚îî‚îÄ‚îÄ app-image/               # Docker + integration tests
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ main/docker/     # Dockerfile, entrypoint.sh
    ‚îÇ   ‚îî‚îÄ‚îÄ integrationTest/
    ‚îÇ       ‚îú‚îÄ‚îÄ groovy/      # Test code
    ‚îÇ       ‚îî‚îÄ‚îÄ resources/
    ‚îÇ           ‚îî‚îÄ‚îÄ compose/ # Docker Compose file
    ‚îî‚îÄ‚îÄ build.gradle         # Plugin config
```

### 2. Update build.gradle

```groovy
dockerOrch {
    composeStacks {
        myAppTest {
            files.from('src/integrationTest/resources/compose/my-app.yml')
            projectName = "my-app-test"  // Make unique!

            waitForHealthy {
                waitForServices.set(['my-service'])
                timeoutSeconds.set(60)
            }
        }
    }
}
```

### 3. Write Your Tests

```groovy
class MyAppIT extends Specification {

    static String baseUrl

    def setupSpec() {
        // Read state file
        def stateFile = new File(System.getProperty('COMPOSE_STATE_FILE'))
        def state = new JsonSlurper().parse(stateFile)
        def port = state.services['my-service'].publishedPorts[0].host
        baseUrl = "http://localhost:${port}"
        RestAssured.baseURI = baseUrl
    }

    def "should test your business logic"() {
        // Your tests here
    }
}
```

### 4. Run Tests

```bash
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  :your-project:app-image:runIntegrationTest
```

## Troubleshooting

**Container fails health check**:
- Check health check command works inside container: `docker exec <container> curl localhost:8080/health`
- Increase `start_period` if app needs more initialization time
- Check application logs: `docker logs <container>`

**Port conflicts**:
- Use random port assignment: `"8080"` (not `"9091:8080"`)
- Plugin assigns random host ports to avoid conflicts

**Tests can't connect to app**:
- Verify state file exists: `build/compose-state/isolatedTestsTest-state.json`
- Check port mapping in state file
- Ensure `composeUp` completed successfully before `integrationTest`

**RestAssured not found**:
- Add dependency: `integrationTestImplementation 'io.rest-assured:rest-assured:5.3.0'`
- Add AFTER sourceSets configuration

## See Also

- **Verification tests**: `../../verification/basic/README.md` - Plugin mechanics validation
- **Plugin documentation**: `/docs/usage/usage-docker-orch.md` - Full plugin reference
- **RestAssured docs**: https://rest-assured.io/ - REST testing framework
