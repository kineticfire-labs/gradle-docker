/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.kineticfire.test

import spock.lang.Specification
import groovy.json.JsonSlurper
import io.restassured.RestAssured
import static io.restassured.RestAssured.given

/**
 * Example: Testing with METHOD Lifecycle for Complete Isolation
 *
 * This example demonstrates **when and why to use METHOD lifecycle** for integration testing.
 *
 * METHOD lifecycle means:
 * - Containers start in setup() before EACH test method
 * - One test method runs
 * - Containers stop in cleanup() after EACH test method
 * - State does NOT persist between test methods
 *
 * This example tests a database-backed user API where:
 * 1. Test 1: Create user "alice"
 * 2. Test 2: Verify user "alice" does NOT exist (fresh database!)
 * 3. Test 3: Create user "alice" again (should succeed because database is fresh)
 * 4. Test 4: Create user "bob"
 * 5. Test 5: Verify user "bob" does NOT exist (fresh database!)
 *
 * Why METHOD lifecycle is appropriate here:
 * - Each test needs a completely clean database
 * - Tests must be independent and idempotent (can run in any order)
 * - Demonstrates database isolation (no data persists between tests)
 * - Proves containers restart for each test
 *
 * Trade-off: SLOWER than CLASS lifecycle (containers restart for each test) but guarantees isolation.
 *
 * When NOT to use METHOD lifecycle:
 * - When tests build on each other (workflow: register → login → update)
 * - When startup time is expensive and state isolation isn't critical
 * - When testing read-only operations against the same data
 * → For these cases, see the stateful-web-app example with CLASS lifecycle
 *
 * Copy and adapt this example for your own isolated testing scenarios!
 */
class IsolatedTestsExampleIT extends Specification {

    // Instance variables (NOT static!) - fresh for each test
    String baseUrl

    // Static counters to track lifecycle calls
    static int setupCallCount = 0
    static int cleanupCallCount = 0

    def setup() {
        setupCallCount++

        // Read the state file generated by dockerOrch plugin
        def stateFilePath = System.getProperty('COMPOSE_STATE_FILE')
        def stateFile = new File(stateFilePath)
        def stateData = new JsonSlurper().parse(stateFile)

        // Extract the host port for the isolated-tests service
        def port = stateData.services['isolated-tests'].publishedPorts[0].host
        baseUrl = "http://localhost:${port}"

        println "=== Test ${setupCallCount}: Fresh environment at ${baseUrl} ==="
        println "=== Using METHOD lifecycle - containers restart for each test ==="

        // Configure RestAssured
        RestAssured.baseURI = baseUrl
    }

    def cleanup() {
        cleanupCallCount++
        println "=== Test ${cleanupCallCount} completed, containers stopping ==="
    }

    // Test 1: Create user "alice"
    def "test 1: should create user alice with fresh database"() {
        when: "we create user alice"
        def response = given()
            .contentType("application/json")
            .body('{"username":"alice","email":"alice@example.com"}')
            .post("/users")

        then: "user is created successfully"
        response.statusCode() == 200

        and: "response contains user data"
        response.jsonPath().getString("username") == "alice"
        response.jsonPath().getString("email") == "alice@example.com"
        response.jsonPath().getLong("id") == 1

        println "✓ Test 1: User 'alice' created with ID ${response.jsonPath().getLong('id')}"
    }

    // Test 2: Verify database is fresh (alice should NOT exist)
    def "test 2: should NOT find alice (database is fresh)"() {
        when: "we try to get user alice"
        def response = given()
            .get("/users/alice")

        then: "user does NOT exist (database is fresh)"
        response.statusCode() == 404

        println "✓ Test 2: User 'alice' does NOT exist (proves isolation!)"
    }

    // Test 3: Create user "alice" again (should succeed with fresh database)
    def "test 3: should create user alice again with fresh database"() {
        when: "we create user alice again"
        def response = given()
            .contentType("application/json")
            .body('{"username":"alice","email":"alice@example.com"}')
            .post("/users")

        then: "user is created successfully (fresh database!)"
        response.statusCode() == 200

        and: "response contains user data"
        response.jsonPath().getString("username") == "alice"
        response.jsonPath().getLong("id") == 1  // ID is 1 again because database is fresh!

        println "✓ Test 3: User 'alice' created again with ID 1 (proves fresh database!)"
    }

    // Test 4: Create user "bob"
    def "test 4: should create user bob with fresh database"() {
        when: "we create user bob"
        def response = given()
            .contentType("application/json")
            .body('{"username":"bob","email":"bob@example.com"}')
            .post("/users")

        then: "user is created successfully"
        response.statusCode() == 200

        and: "response contains user data"
        response.jsonPath().getString("username") == "bob"
        response.jsonPath().getString("email") == "bob@example.com"
        response.jsonPath().getLong("id") == 1

        println "✓ Test 4: User 'bob' created with ID ${response.jsonPath().getLong('id')}"
    }

    // Test 5: Verify database is fresh (bob should NOT exist)
    def "test 5: should NOT find bob (database is fresh)"() {
        when: "we try to get user bob"
        def response = given()
            .get("/users/bob")

        then: "user does NOT exist (database is fresh)"
        response.statusCode() == 404

        println "✓ Test 5: User 'bob' does NOT exist (proves isolation!)"
    }

    // Test 6: Verify no users exist
    def "test 6: should have empty database (no users from previous tests)"() {
        when: "we get all users"
        def response = given()
            .get("/users")

        then: "no users exist"
        response.statusCode() == 200

        and: "response is empty array"
        def users = response.jsonPath().getList("$")
        users.size() == 0

        println "✓ Test 6: Database is empty (no users from previous tests)"
    }

    // Test 7: Health check
    def "test 7: should respond to health check endpoint"() {
        when: "we call the /health endpoint"
        def response = given()
            .get("/health")

        then: "app is healthy"
        response.statusCode() == 200
        response.jsonPath().getString("status") == "UP"
        response.jsonPath().getLong("userCount") == 0  // Fresh database!

        println "✓ Test 7: Health check passed, userCount = 0 (fresh database)"
    }
}
