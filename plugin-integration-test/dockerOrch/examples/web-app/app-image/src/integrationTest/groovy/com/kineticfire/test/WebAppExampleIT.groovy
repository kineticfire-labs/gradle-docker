/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.kineticfire.test

import spock.lang.Specification
import groovy.json.JsonSlurper
import io.restassured.RestAssured
import static io.restassured.RestAssured.given

/**
 * Example: Testing a Web Application with Docker Compose
 *
 * This example demonstrates how to test a Spring Boot REST API using the dockerOrch plugin.
 *
 * The dockerOrch plugin handles:
 * - Building the Docker image from your JAR
 * - Starting containers with Docker Compose
 * - Waiting for the app to be healthy
 * - Providing port mapping information
 * - Cleaning up after tests
 *
 * Your tests focus on:
 * - Testing your application's business logic
 * - Validating API contracts
 * - Checking error handling
 * - Testing concurrent behavior
 *
 * Copy and adapt this example for your own projects!
 */
class WebAppExampleIT extends Specification {

    static String baseUrl

    def setupSpec() {
        // Read the state file generated by dockerOrch plugin
        // This file contains container info including published ports
        def stateFilePath = System.getProperty('COMPOSE_STATE_FILE')
        def stateFile = new File(stateFilePath)
        def stateData = new JsonSlurper().parse(stateFile)

        // Extract the host port for the web-app service
        // The plugin maps container port 8080 to a random host port
        def port = stateData.services['web-app'].publishedPorts[0].host

        baseUrl = "http://localhost:${port}"

        println "=== Testing Web App at ${baseUrl} ==="

        // Configure RestAssured base URL
        RestAssured.baseURI = baseUrl
    }

    def "should respond to health check endpoint"() {
        when: "we call the /health endpoint"
        def response = given()
            .get("/health")

        then: "we get 200 OK"
        response.statusCode() == 200

        and: "response indicates app is UP"
        response.jsonPath().getString("status") == "UP"
        response.jsonPath().getString("timestamp") != null
    }

    def "should return app information from root endpoint"() {
        when: "we call the root endpoint"
        def response = given()
            .get("/")

        then: "we get 200 OK"
        response.statusCode() == 200

        and: "response contains app information"
        response.jsonPath().getString("message") == "Web App is running"
        response.jsonPath().getString("version") == "1.0.0"
    }

    def "should handle multiple concurrent requests successfully"() {
        given: "we want to test concurrent load"
        def concurrentRequests = 50

        when: "we make many concurrent requests"
        def results = (1..concurrentRequests).collect {
            Thread.start {
                given()
                    .get("/health")
                    .statusCode()
            }
        }*.join()

        then: "all requests should succeed"
        results.size() == concurrentRequests
        results.every { it == 200 }
    }

    def "should return JSON content type"() {
        when: "we call any endpoint"
        def response = given()
            .get("/health")

        then: "content type is JSON"
        response.contentType().contains("application/json")
    }

    def "health endpoint should respond quickly"() {
        when: "we measure response time"
        def startTime = System.currentTimeMillis()
        def response = given()
            .get("/health")
        def responseTime = System.currentTimeMillis() - startTime

        then: "request succeeds"
        response.statusCode() == 200

        and: "response is fast (under 1 second)"
        responseTime < 1000
    }
}
