# Verification Test: Wait-Running (No Health Check)

**Type**: Plugin Mechanics Validation
**Lifecycle**: CLASS (setupSpec/cleanupSpec)
**Purpose**: Validates waitForRunning functionality for containers WITHOUT health checks

## What This Test Validates

This verification test ensures the dockerTest plugin correctly:
- ✅ Waits for containers to reach RUNNING state (not healthy)
- ✅ Works with containers that have NO health check configured
- ✅ Respects timeout configuration (60 seconds)
- ✅ Respects poll interval configuration (2 seconds)
- ✅ Generates state files with correct structure and data
- ✅ Maps ports correctly (container → host)
- ✅ Makes services accessible via HTTP
- ✅ Stops Docker Compose stacks with `composeDown`
- ✅ Cleans up all containers, networks, and volumes

## Key Differences from Wait-Healthy Test

| Aspect | Wait-Healthy Test | Wait-Running Test |
|--------|------------------|-------------------|
| **Health Check** | Configured in Docker Compose | NO health check |
| **Wait Configuration** | `waitForHealthy` | `waitForRunning` |
| **Container State** | HEALTHY | RUNNING |
| **Startup Delay** | 5000ms (5 seconds) | None |
| **Timeout** | 90 seconds | 60 seconds |
| **Poll Interval** | 1 second | 2 seconds |
| **Timing Tests** | Yes - validates uptime | No - just validates running |
| **Health Status** | Verified in tests | Not applicable |

## Test Lifecycle

**Lifecycle Type**: `CLASS`

The test uses Spock's `setupSpec()` and `cleanupSpec()` methods:
- `setupSpec()` - Runs once before all tests in the class (reads state file)
- Tests run with the same Docker Compose stack (started by `composeUpWaitRunningTest` task)
- Cleanup is handled by Gradle task workflow (no `cleanupSpec()` needed)

This mirrors how real users would test: start containers once, run multiple tests, tear down once.

## Test Configuration

### Application Startup
- **Startup Delay**: None - application starts immediately
- **Purpose**: Tests basic waitForRunning functionality

### Docker Compose Configuration
- **NO Health Check**: This is the key difference - no healthcheck configured
- **Service Name**: `wait-running-app`
- **Port**: 8080 (mapped to random host port)

### Wait-Running Configuration
- **Timeout**: 60 seconds
- **Poll Interval**: 2 seconds
- **Services**: `wait-running-app`

## Running Tests

**⚠️ Important**: All commands must be run from `plugin-integration-test/` directory.

### Full Integration Test Workflow

```bash
# From plugin-integration-test/ directory
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:wait-running:app-image:runIntegrationTest
```

This runs:
1. Build app JAR (simple Spring Boot app)
2. Build Docker image (no healthcheck)
3. Start Docker Compose stack (`composeUpWaitRunningTest`)
4. Wait for container to be RUNNING (up to 60 seconds, polling every 2 seconds)
5. Run integration tests (validates running state and HTTP accessibility)
6. Stop Docker Compose stack (`composeDownWaitRunningTest`)

### Individual Tasks

```bash
# Clean build artifacts
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:wait-running:clean

# Build the app
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:wait-running:app:bootJar

# Build Docker image
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:wait-running:app-image:dockerBuildWaitRunningApp

# Start Docker Compose stack
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:wait-running:app-image:composeUpWaitRunningTest

# Run tests (requires stack to be up)
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:wait-running:app-image:integrationTest

# Stop Docker Compose stack
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:wait-running:app-image:composeDownWaitRunningTest
```

### Clean Everything

```bash
# Clean build artifacts and Docker images
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:wait-running:clean \
  dockerTest:verification:wait-running:app:clean \
  dockerTest:verification:wait-running:app-image:clean
```

## Test Structure

```groovy
class WaitRunningPluginIT extends Specification {

    static String projectName
    static Map stateData

    def setupSpec() {
        // Runs ONCE before all tests
        // Reads state file generated by composeUp
        projectName = System.getProperty('COMPOSE_PROJECT_NAME')
        stateData = StateFileValidator.parseStateFile(stateFile)
    }

    def "plugin should generate valid state file"() { ... }
    def "plugin should start container in running state"() { ... }
    def "plugin should wait for running state without health check"() { ... }
    def "plugin should make service accessible via HTTP"() { ... }
    def "plugin should make health endpoint accessible"() { ... }
    def "plugin should respect timeout configuration"() { ... }
    def "plugin should respect poll interval configuration"() { ... }
    def "plugin should map ports correctly"() { ... }
    def "plugin should record state file timestamp"() { ... }
}
```

## Tests Performed

### 1. State File Validation
Validates that the state file:
- Has correct structure (stackName, projectName, timestamp, services)
- Contains `wait-running-app` service
- Has port mapping information

### 2. Container Running State
Validates that the container is in RUNNING state using `docker ps`.

### 3. Container Has No Health Check
Validates that:
- Container is running
- Container does NOT have health check configured
- This is the key difference from wait-healthy test

### 4. HTTP Accessibility - Root Endpoint
Validates that:
- Root endpoint (/) is accessible via HTTP
- Returns expected JSON response
- Service is fully functional

### 5. HTTP Accessibility - Health Endpoint
Validates that:
- Health endpoint (/health) is accessible via HTTP
- Returns status "UP"
- Application is responding correctly

### 6. Timeout Configuration
Validates that:
- The 60-second timeout was respected
- The container reached running state within the timeout window
- This is tested implicitly - if timeout was too short, composeUp would have failed

### 7. Poll Interval Configuration
Validates that:
- The 2-second poll interval was used
- The plugin polled correctly before success
- This is tested implicitly by the successful running status

### 8. Port Mapping
Validates that:
- Ports are mapped correctly from container (8080) to host
- State file contains accurate port mapping information

### 9. State File Timestamp
Validates that:
- State file contains timestamp
- Timestamp is in ISO 8601 format

## Validation Tools Used

This test uses internal validators from `buildSrc/`:

- **`StateFileValidator`** - Validates state file structure and content
  - `parseStateFile()` - Parse JSON state file
  - `assertValidStructure()` - Check required fields
  - `getPublishedPort()` - Extract port mappings
  - `getServiceInfo()` - Get service details

- **`DockerComposeValidator`** - Validates Docker Compose state
  - `isContainerRunning()` - Check container is running
  - `hasHealthCheck()` - Check if container has health check

- **`CleanupValidator`** - Ensures no resource leaks
  - `verifyCleanup()` - Assert no containers/networks remain
  - `forceCleanup()` - Force removal if verification fails

## Expected Results

All 9 tests should pass:
- ✅ State file has valid structure with all required fields
- ✅ Container is in RUNNING state
- ✅ Container has NO health check configured
- ✅ Root endpoint (/) is accessible and returns correct data
- ✅ Health endpoint (/health) is accessible and returns UP
- ✅ Timeout configuration (60 seconds) was respected
- ✅ Poll interval (2 seconds) was respected
- ✅ Port mapping is correct (state file matches Docker)
- ✅ State file has valid timestamp

No containers should remain after tests complete.

## Troubleshooting

**Tests fail with "container not found"**:
- Ensure `composeUpWaitRunningTest` ran successfully before `integrationTest`
- Use `runIntegrationTest` task which handles dependencies automatically

**Tests fail with "state file not found"**:
- State file is at `build/compose-state/waitRunningTest-state.json`
- Ensure `composeUpWaitRunningTest` completed successfully

**Tests fail with "connection refused" on HTTP calls**:
- Check that container is actually running: `docker ps -a | grep wait-running`
- Verify port mapping: check state file or `docker ps`
- Check container logs: `docker logs <container-id>`

**Cleanup verification fails**:
- Run manual cleanup: `docker ps -a -q --filter "name=verification-wait-running" | xargs -r docker rm -f`
- Check for lingering networks: `docker network ls | grep verification-wait-running`

**Timeout occurs during composeUp**:
- Check if 60 second timeout is sufficient for your environment
- Verify container starts correctly without errors
- Check container logs for startup errors

**Port already in use**:
- Docker Compose uses random host ports to avoid conflicts
- Check actual port in state file

## Use Case

This test validates the plugin's ability to:
1. **Wait for containers that don't have health checks**
   - Many containers don't define health checks
   - Plugin should handle this gracefully
   - Wait for "running" state is sufficient for these cases

2. **Provide simpler configuration for basic services**
   - Not all services need health checks
   - `waitForRunning` is simpler than `waitForHealthy`
   - Useful for services that start quickly

3. **Support rapid testing workflows**
   - No health check means faster startup
   - Useful for development and testing
   - Reduces complexity in Docker Compose files

## ⚠️ This is NOT a User Example

This test validates plugin mechanics using internal tools. For user-facing examples of how to test applications, see
`../../examples/web-app/README.md`.
