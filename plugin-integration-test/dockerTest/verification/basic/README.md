# Verification Test: Basic Docker Compose Up/Down

**Type**: Plugin Mechanics Validation
**Lifecycle**: CLASS (setupSpec/cleanupSpec)
**Purpose**: Validates basic dockerTest plugin functionality

## What This Test Validates

This verification test ensures the dockerTest plugin correctly:
- ✅ Starts Docker Compose stacks with `composeUp`
- ✅ Waits for containers to become HEALTHY
- ✅ Generates state files with correct structure and data
- ✅ Maps ports correctly (container → host)
- ✅ Stops Docker Compose stacks with `composeDown`
- ✅ Cleans up all containers, networks, and volumes

## Test Lifecycle

**Lifecycle Type**: `CLASS`

The test uses Spock's `setupSpec()` and `cleanupSpec()` methods:
- `setupSpec()` - Runs once before all tests in the class (reads state file)
- `cleanupSpec()` - Runs once after all tests in the class (verifies cleanup)
- Tests run with the same Docker Compose stack (started by `composeUpWebAppTest` task)

This mirrors how real users would test: start containers once, run multiple tests, tear down once.

## Running Tests

**⚠️ Important**: All commands must be run from `plugin-integration-test/` directory.

### Full Integration Test Workflow

```bash
# From plugin-integration-test/ directory
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:basic:app-image:runIntegrationTest
```

This runs:
1. Build app JAR
2. Build Docker image
3. Start Docker Compose stack (`composeUpWebAppTest`)
4. Wait for container to be HEALTHY
5. Run integration tests
6. Stop Docker Compose stack (`composeDownWebAppTest`)

### Individual Tasks

```bash
# Clean build artifacts
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:basic:clean

# Build the app
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:basic:app:bootJar

# Build Docker image
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:basic:app-image:dockerBuildWebApp

# Start Docker Compose stack
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:basic:app-image:composeUpWebAppTest

# Run tests (requires stack to be up)
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:basic:app-image:integrationTest

# Stop Docker Compose stack
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:basic:app-image:composeDownWebAppTest
```

### Clean Everything

```bash
# Clean build artifacts and Docker images
./gradlew -Pplugin_version=1.0.0-SNAPSHOT \
  dockerTest:verification:basic:clean \
  dockerTest:verification:basic:app:clean \
  dockerTest:verification:basic:app-image:clean
```

## Test Configuration

### Docker Compose Stack

- **Stack Name**: `webAppTest`
- **Project Name**: `verification-basic-web-app-test`
- **Image Name**: `verification-basic-web-app:latest`
- **Service**: `web-app`
- **Wait Strategy**: `waitForHealthy` (60 second timeout, 2 second poll)

### Test Structure

```groovy
class BasicPluginIT extends Specification {

    static String projectName
    static Map stateData

    def setupSpec() {
        // Runs ONCE before all tests
        // Reads state file generated by composeUp
        projectName = System.getProperty('COMPOSE_PROJECT_NAME')
        stateData = StateFileValidator.parseStateFile(stateFile)
    }

    def "plugin should generate valid state file"() { ... }
    def "plugin should start container in running state"() { ... }
    def "plugin should wait until container is healthy"() { ... }
    def "plugin should map ports correctly"() { ... }

    def cleanupSpec() {
        // Runs ONCE after all tests
        // Verifies no resource leaks
        CleanupValidator.verifyCleanup(projectName)
    }
}
```

## Validation Tools Used

This test uses internal validators from `buildSrc/`:

- **`StateFileValidator`** - Validates state file structure and content
  - `parseStateFile()` - Parse JSON state file
  - `assertValidStructure()` - Check required fields
  - `getPublishedPort()` - Extract port mappings
  - `getServiceInfo()` - Get service details

- **`DockerComposeValidator`** - Validates Docker Compose state
  - `isContainerRunning()` - Check container is running
  - `isContainerHealthy()` - Check container health status

- **`CleanupValidator`** - Ensures no resource leaks
  - `verifyCleanup()` - Assert no containers/networks remain
  - `forceCleanup()` - Force removal if verification fails

## Expected Results

All 4 tests should pass:
- ✅ State file has valid structure with all required fields
- ✅ Container is in RUNNING state
- ✅ Container is HEALTHY (health check passed)
- ✅ Port mapping is correct (state file matches Docker)

No containers should remain after tests complete.

## Troubleshooting

**Tests fail with "container not found"**:
- Ensure `composeUpWebAppTest` ran successfully before `integrationTest`
- Use `runIntegrationTest` task which handles dependencies automatically

**Tests fail with "state file not found"**:
- State file is at `build/compose-state/webAppTest-state.json`
- Ensure `composeUpWebAppTest` completed successfully

**Cleanup verification fails**:
- Run manual cleanup: `docker ps -a -q --filter "name=verification-basic" | xargs -r docker rm -f`
- Check for lingering networks: `docker network ls | grep verification-basic`

**Port already in use**:
- Docker Compose uses random host ports to avoid conflicts
- Check actual port in state file

## ⚠️ This is NOT a User Example

This test validates plugin mechanics using internal tools. For user-facing examples of how to test applications, see `../../examples/web-app/README.md`.
