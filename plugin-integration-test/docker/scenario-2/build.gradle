/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Integration test that tests:
 *   - Build Image Features
 *       - number of images = 1
 *       - number of build args = 1
 *       - dockerfile = specify by name
 *   - Tag Features
 *       - number of tags = 1
 *   - Save Features
 *       - save w/ compression type = none
 *       - save w/ no pullIfMissing
 *   - Publish Features
 *       - publish = 1 tag
 *       - publish to private registry without authentication
 */

plugins {
    id 'groovy'
    id 'com.kineticfire.gradle.gradle-docker' version '1.0.0'
}

group = 'com.kineticfire.gradle.docker.integration'
version = '1.0.0'

docker {
    images {
        timeServer {
            contextTask = tasks.register('prepareScenario2TimeServerContext', Copy) {
                group = 'docker'
                description = 'Prepare Docker build context for time server image'
                into layout.buildDirectory.dir('docker-context/timeServer')
                from('src/main/docker')
                from(file('../../app/build/libs')) {
                    include 'app-*.jar'
                    def projectVersion = version
                    rename { "app-${projectVersion}.jar" }
                }
                dependsOn ':app:jar'
            }
            dockerfileName = 'CustomDockerfile'
            buildArgs = ['JAR_FILE': "app-${version}.jar"]
            tags.set(["scenario2-time-server:latest"])
            save {
                outputFile = file('build/docker-images/scenario2-time-server-latest.tar')
                compression = 'none'
                // 'pullIfMissing' will default to 'false'
            }
            publish {
                to('testRegistry') {
                    tags(['localhost:5200/scenario2-time-server:latest'])
                }
            }
        }
    }
}

// ============================================================================
// INTEGRATION TEST VERIFICATION TASKS
// ============================================================================

// Apply the reusable Docker image testing plugin from buildSrc
apply from: "$rootDir/buildSrc/src/main/groovy/docker-image-testing.gradle"

// Manual registry management for demonstration
def registryPort = 5200
def registryContainer = "test-registry-scenario2"

// Register Docker image clean and verify tasks for this integration test
registerBuildWorkflowTasks(project, ['scenario2-time-server:latest'])

// Register saved image verification task since this scenario tests save functionality
registerVerifySavedImagesTask(project, ['build/docker-images/scenario2-time-server-latest.tar'])

// Register registry image verification task since this scenario tests publish functionality
registerVerifyRegistryImagesTask(project, ['localhost:5200/scenario2-time-server:latest'])

// Create manual registry tasks for demonstration
tasks.register('startTestRegistry') {
    group = 'docker registry'
    description = 'Start test Docker registry'
    doLast {
        // Simple approach using bash commands
        "docker rm -f ${registryContainer}".execute().waitFor()
        def startResult = "docker run -d --name ${registryContainer} -p ${registryPort}:5000 registry:2".execute()
        startResult.waitFor()
        if (startResult.exitValue() != 0) {
            throw new RuntimeException("Failed to start registry")
        }
        
        // Wait for registry to be ready
        println "Waiting for registry to be ready..."
        for (int i = 0; i < 30; i++) {
            def healthCheck = "curl -f -s http://localhost:${registryPort}/v2/".execute()
            healthCheck.waitFor()
            if (healthCheck.exitValue() == 0) {
                println "✓ Registry is ready at localhost:${registryPort}"
                return
            }
            Thread.sleep(1000)
        }
        throw new RuntimeException("Registry failed to become ready")
    }
}

tasks.register('stopTestRegistry') {
    group = 'docker registry'
    description = 'Stop test Docker registry'
    doLast {
        "docker rm -f ${registryContainer}".execute().waitFor()
        println "✓ Registry stopped and removed"
    }
}

// Task that runs complete integration test workflow  
tasks.register('integrationTest') {
    description = 'Run complete Docker integration test: clean → build → save → publish → verify'
    group = 'verification'
    
    // Dependencies
    dependsOn 'startTestRegistry'
    dependsOn 'cleanDockerImages'
    dependsOn 'dockerImages'
    dependsOn 'verifyDockerImages'
    dependsOn 'verifySavedDockerImages'
    dependsOn 'verifyRegistryDockerImages'
    dependsOn 'stopTestRegistry'
    
    // Ensure proper task ordering
    tasks.cleanDockerImages.mustRunAfter tasks.startTestRegistry
    tasks.dockerImages.mustRunAfter tasks.cleanDockerImages
    tasks.verifyDockerImages.mustRunAfter tasks.dockerImages
    tasks.verifySavedDockerImages.mustRunAfter tasks.dockerImages
    tasks.verifyRegistryDockerImages.mustRunAfter tasks.dockerImages
    tasks.stopTestRegistry.mustRunAfter tasks.verifyRegistryDockerImages
}