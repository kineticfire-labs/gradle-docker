/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Integration test that tests:
 *   - Build Image Features
 *       - number of images = 1
 *       - build image only vs follow-on: build image only
 *       - naming style: Image Name Mode: imageName, tag(s)
 *       - build args
 *           - number of build args > 1
 *           - number of build args w/ put > 1
 *       - labels
 *           - number of labels > 1
 *           - number of labels w/ put > 1
 *       - dockerfile = default
 *   - Tag Features
 *       - number of tags > 1
 *   - Save Features
 *       - save = none
 *   - Publish Features
 *       - publish = none
 */

plugins {
    id 'groovy'
    id 'com.kineticfire.gradle.gradle-docker'
}

group = 'com.kineticfire.gradle.docker.integration'
version = '1.0.0'

docker {
    images {
        timeServer {

            contextTask = tasks.register('prepareScenario1TimeServerContext', Copy) {
                group = 'docker'
                description = 'Prepare Docker build context for time server image'
                into layout.buildDirectory.dir('docker-context/timeServer')
                from('src/main/docker')

                // Only copy app JAR when running from parent project (where :app project exists)
                if (rootProject.name == 'plugin-integration-test') {
                    // Capture version as string during configuration to avoid closure access at execution
                    def versionString = project.version.toString()
                    from(file('../../app/build/libs')) {
                        include 'app-*.jar'
                        rename { String fileName -> "app-${versionString}.jar" }
                    }
                    dependsOn ':app:jar'
                } else {
                    // For standalone execution, create a dummy JAR file for testing
                    // Capture version during configuration for configuration cache compatibility
                    def versionString = project.version.toString()
                    doFirst {
                        def jarFile = new File(destinationDir, "app-${versionString}.jar")
                        jarFile.parentFile.mkdirs()
                        jarFile.createNewFile()
                        jarFile.text = "dummy jar for standalone testing"
                    }
                }
            }

            buildArgs.put("JAR_FILE", "app-${project.version}.jar")
            buildArgs.put("BUILD_VERSION", project.version.toString())

            labels.put("org.opencontainers.image.version", project.version.toString())
            labels.put("maintainer", "team@kineticfire.com")

            // dockerfile will default to 'build/docker-context/timeServer/Dockerfile'

            imageName.set('scenario1-time-server')
            tags.set([
                    "1.0.0",
                    "latest"
            ])

            // no save
            // no publish
        }
    }
}

// ============================================================================
// INTEGRATION TEST VERIFICATION TASKS
// ============================================================================

// Apply buildSrc components only when running from parent project (where buildSrc is available)
if (rootProject.name == 'plugin-integration-test') {
    // Apply the reusable Docker image testing plugin from buildSrc
    apply from: "$rootDir/buildSrc/src/main/groovy/docker-image-testing.gradle"

    // Register Docker image clean and verify tasks for this integration test
    registerBuildWorkflowTasks(project, [
        'scenario1-time-server:1.0.0',
        'scenario1-time-server:latest'
    ])

    // Task that runs complete integration test workflow
    tasks.register('integrationTest') {
        description = 'Run complete Docker integration test: clean → build → verify'
        group = 'verification'
        dependsOn 'cleanDockerImages'
        dependsOn 'dockerBuild'
        dependsOn 'verifyDockerImages'

        // Configure task ordering using provider-based configuration
        doFirst {
            // Ensure proper task ordering without afterEvaluate
        }
    }

    // Configure task ordering immediately without afterEvaluate
    tasks.named('dockerBuild') { mustRunAfter 'cleanDockerImages' }
    tasks.named('verifyDockerImages') { mustRunAfter 'dockerBuild' }
}

// Task that runs integration test workflow (different behavior based on execution context)
if (rootProject.name != 'plugin-integration-test') {
    // When running standalone, create a simplified integrationTest task for plugin verification
    tasks.register('integrationTest') {
        description = 'Run simplified integration test to verify plugin version resolution'
        group = 'verification'
        dependsOn 'dockerBuild'

        // Capture task names during configuration for configuration cache compatibility
        def dockerTaskNames = tasks.findAll { it.name.startsWith('docker') }.collect { it.name }
        doFirst {
            println "✅ Plugin version resolved successfully for standalone execution!"
            println "✅ Available docker tasks: ${dockerTaskNames}"
        }
    }
}
