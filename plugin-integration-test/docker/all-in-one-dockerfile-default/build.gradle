/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * App-Image subproject - builds Docker image and runs integration tests.
 * 
 * This demonstrates how developers would use the gradle-docker plugin to:
 * - Build Docker images using the docker {} DSL (UC-6)  
 * - Test images using Docker Compose orchestration with dockerOrch {} DSL (UC-7)
 * - Use different lifecycle patterns (suite, class, method)
 * 
 * This subproject showcases realistic usage patterns developers would follow.
 */

plugins {
    id 'groovy'
    id 'com.kineticfire.gradle.gradle-docker' version '1.0.0'
}

group = 'com.kineticfire.gradle.docker.integration'
version = '1.0.0'

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    // Docker Java Client for image verification
    implementation libs.docker.java.core
    implementation libs.docker.java.transport.httpclient5
}

// Handle duplicate resources
tasks.withType(ProcessResources) {
    duplicatesStrategy = DuplicatesStrategy.WARN
}

// Setup all-in-one 'docker' tasks:  build, tag, save, and publish
docker {
    images {

        // Define build, tag, save, and publish actions for the image 'timeServer'
        timeServer {

            // Define the Docker build context use to build the Docker image.  The build context is a directory whose
            // contents are used in the image build process.  The 'contextTask' takes a Gradle 'Copy' task, so one or
            // more files/directories may be included to create the build context.
            //
            // For debug purposes, inspect the Docker build context at 'build/docker-context/timeServer'.
            contextTask = tasks.register('prepareTimeServerContext', Copy) {
                group = 'docker'
                description = 'Prepare Docker build context for time server image'
                into layout.buildDirectory.dir('docker-context/timeServer')
                from('src/main/docker')
                from(file('../../app/build/libs')) {
                    include 'app-*.jar'
                    def projectVersion = version // Capture version during configuration time
                    rename { "app-${projectVersion}.jar" }
                }
                dependsOn ':app:jar'
            }
            // dockerfile will default to 'build/docker-context/timeServer/Dockerfile' based on image name
            //dockerfileName = 'Dockerfile'
            tags.set([  // note different syntax to list tax vs docker/images/<name>/publish/to/publishTags
                        "${version}",
                        "latest"
            ])
            buildArgs = [
                'JAR_FILE': "app-${version}.jar",
                'BUILD_VERSION': version,
                'BUILD_TIME': new Date().format('yyyy-MM-dd HH:mm:ss')
            ]
            //publish {
            //    to('basic') {
            //        repository = 'localhost:25000/time-server-integration'
            //        publishTags = ['latest'] // note different syntax to list tax vs docker/images/<name>/tags
            //    }
            //}
        }

        // Build additional images by repeating the 'timeServer' configuration block template here
    }
}

// ============================================================================
// INTEGRATION TEST VERIFICATION TASKS
// ============================================================================

// Task to clean up Docker images before building (ensures clean test state)
tasks.register('cleanDockerImages') {
    description = 'Remove Docker images before building to ensure clean integration test'
    group = 'verification'
    
    doLast {
        // Remove Docker images using Docker CLI (configuration cache compatible)
        ['time-server:1.0.0', 'time-server:latest'].each { fullImageName ->
            try {
                // Check if image exists using ProcessBuilder
                def checkProcess = new ProcessBuilder('docker', 'images', '-q', fullImageName)
                    .redirectErrorStream(true)
                    .start()
                def checkOutput = checkProcess.inputStream.text.trim()
                checkProcess.waitFor()
                
                if (checkProcess.exitValue() == 0 && checkOutput) {
                    println "Removing existing image: ${fullImageName}"
                    def removeProcess = new ProcessBuilder('docker', 'rmi', '-f', fullImageName)
                        .redirectErrorStream(true)
                        .start()
                    removeProcess.waitFor()
                    if (removeProcess.exitValue() == 0) {
                        println "Successfully removed image: ${fullImageName}"
                    } else {
                        println "Warning: Could not remove image ${fullImageName}"
                    }
                } else {
                    println "Image ${fullImageName} does not exist, skipping removal"
                }
            } catch (Exception e) {
                println "Warning: Could not process image ${fullImageName}: ${e.message}"
            }
        }
    }
}

// Task to verify Docker images were created after building
tasks.register('verifyDockerImages') {
    description = 'Verify Docker images were created with expected tags'
    group = 'verification'
    
    doLast {
        // Verify Docker images using Docker CLI (configuration cache compatible)
        def failedImages = []
        
        ['time-server:1.0.0', 'time-server:latest'].each { fullImageName ->
            try {
                // Check if image exists using ProcessBuilder
                def checkProcess = new ProcessBuilder('docker', 'images', '-q', fullImageName)
                    .redirectErrorStream(true)
                    .start()
                def checkOutput = checkProcess.inputStream.text.trim()
                checkProcess.waitFor()
                
                if (checkProcess.exitValue() == 0 && checkOutput) {
                    println "✓ Verified image exists: ${fullImageName}"
                } else {
                    failedImages.add(fullImageName)
                    println "✗ Expected image ${fullImageName} was not found!"
                }
            } catch (Exception e) {
                failedImages.add(fullImageName)
                println "✗ Error checking image ${fullImageName}: ${e.message}"
            }
        }
        
        if (!failedImages.isEmpty()) {
            throw new RuntimeException("Expected images were not found: ${failedImages.join(', ')}")
        }
        
        println "✓ All expected Docker images verified successfully!"
    }
}

// Task that runs complete integration test workflow
tasks.register('integrationTest') {
    description = 'Run complete Docker integration test: clean → build → verify'
    group = 'verification'
    dependsOn 'cleanDockerImages'
    dependsOn 'dockerBuildTimeServer'  
    dependsOn 'verifyDockerImages'
    
    // Ensure proper task ordering
    tasks.dockerBuildTimeServer.mustRunAfter tasks.cleanDockerImages
    tasks.verifyDockerImages.mustRunAfter tasks.dockerBuildTimeServer
}


