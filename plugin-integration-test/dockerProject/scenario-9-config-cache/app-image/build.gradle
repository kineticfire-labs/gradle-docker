/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * dockerProject Integration Test: Scenario 9 - Configuration Cache Verification
 *
 * This scenario explicitly verifies that the dockerProject DSL is fully compatible
 * with Gradle's configuration cache. The test runs the pipeline twice with
 * --configuration-cache and verifies that the second run reuses the cached
 * configuration.
 *
 * What this tests:
 * - Configuration cache compatibility with dockerProject DSL
 * - Second run reuses cached configuration (no "Calculating task graph")
 * - All tasks execute correctly from cached state
 * - File-based state communication works with configuration cache
 *
 * Configuration Cache Verification:
 * - First run: Stores configuration in cache
 * - Second run: Must reuse configuration (output contains "Reusing configuration cache")
 * - No configuration cache problems should be reported
 *
 * Port allocation (per README conventions):
 * - Service: 9309 (dockerProject scenario 9)
 */

plugins {
    id 'groovy'
    id 'com.kineticfire.gradle.docker'
}

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    testImplementation libs.groovy.all
    testImplementation libs.spock.core
    testRuntimeOnly libs.junit.platform.launcher
}

// =============================================================================
// DOCKER PROJECT DSL: Basic Configuration for Config Cache Testing
// =============================================================================
// This is a minimal dockerProject configuration designed to test
// configuration cache compatibility without complex features.
dockerProject {
    // images block: Define Docker images to build
    images {
        // Named block 'scenario9App' - the block name is used internally for task naming
        scenario9App {
            // Simple image name
            imageName.set('project-scenario9-app')

            // Tags
            tags.set(['latest'])

            // jarFrom: Reference a task that produces a JAR file
            jarFrom.set(':app:jar')

            // Simple build arg and label
            buildArgs.put('BUILD_VERSION', '1.0.0')
            labels.put('org.opencontainers.image.title', 'Config Cache Test')
        }
    }

    // test block: Configure Docker Compose testing
    test {
        // Path to the Docker Compose file
        compose.set('src/integrationTest/resources/compose/app.yml')

        // Services to wait for HEALTHY status
        waitForHealthy.set(['app'])

        // Timeout for health checks
        timeoutSeconds.set(60)

        // Test task to execute
        testTaskName.set('integrationTest')
    }

    // onSuccess block: Actions when tests pass
    onSuccess {
        // Additional tags to apply when tests succeed
        additionalTags.set(['tested'])
    }
}

// =============================================================================
// Integration Test Dependencies
// =============================================================================
dependencies {
    integrationTestImplementation files("${rootProject.projectDir}/buildSrc/build/classes/groovy/main")
    integrationTestImplementation libs.rest.assured
    integrationTestImplementation libs.rest.assured.json.path
}

// Configure integration test task with system properties
tasks.named('integrationTest') {
    systemProperty 'COMPOSE_PROJECT_NAME', 'project-scenario9-test'
    systemProperty 'IMAGE_NAME', 'project-scenario9-app'
}

// =============================================================================
// Task Orchestration
// =============================================================================
afterEvaluate {
    tasks.named('composeUpProjectscenario9appTest') {
        dependsOn tasks.named('dockerBuildProjectscenario9app')
        dependsOn project(':app').tasks.named('jar')
    }

    // The integration test flow: composeUp -> tests -> composeDown
    tasks.named('integrationTest') {
        dependsOn tasks.named('composeUpProjectscenario9appTest')
        finalizedBy tasks.named('composeDownProjectscenario9appTest')
    }
}

// =============================================================================
// Configuration Cache Verification Tasks
// =============================================================================

/**
 * First run task - runs the pipeline with --configuration-cache
 * This stores the configuration in the cache.
 */
tasks.register('configCacheFirstRun') {
    description = 'First run with configuration cache (stores cache)'
    group = 'verification'

    dependsOn project(':app').tasks.named('jar')
    dependsOn tasks.named('runProjectscenario9appPipeline')

    doLast {
        logger.lifecycle("=== Configuration Cache: First run completed ===")
        logger.lifecycle("Configuration should now be cached")
    }
}

/**
 * Second run task - runs the same pipeline again
 * This should reuse the cached configuration.
 */
tasks.register('configCacheSecondRun') {
    description = 'Second run with configuration cache (reuses cache)'
    group = 'verification'

    mustRunAfter 'configCacheFirstRun'
    dependsOn tasks.named('runProjectscenario9appPipeline')

    doLast {
        logger.lifecycle("=== Configuration Cache: Second run completed ===")
        logger.lifecycle("If configuration cache is working, this run should have said 'Reusing configuration cache'")
    }
}

/**
 * Full configuration cache verification - runs both first and second runs
 */
tasks.register('verifyConfigCache') {
    description = 'Verify configuration cache compatibility (runs pipeline twice)'
    group = 'verification'

    dependsOn 'configCacheFirstRun'
    dependsOn 'configCacheSecondRun'

    doLast {
        logger.lifecycle("=== Configuration Cache Verification Complete ===")
        logger.lifecycle("Check the output above for 'Reusing configuration cache' in the second run")
        logger.lifecycle("If you see 'Calculating task graph' in the second run, config cache is NOT working")
    }
}

// =============================================================================
// Standard Integration Test Task
// =============================================================================
tasks.register('runProjectIntegrationTest') {
    description = 'Run the dockerProject config cache test pipeline'
    group = 'verification'

    dependsOn project(':app').tasks.named('jar')
    dependsOn tasks.named('runProjectscenario9appPipeline')

    doLast {
        // Verify the 'tested' tag was applied
        def process = new ProcessBuilder('docker', 'images', '-q', 'project-scenario9-app:tested')
            .redirectErrorStream(true)
            .start()
        def imageId = process.inputStream.text.trim()
        def exitCode = process.waitFor()

        if (exitCode != 0 || imageId.isEmpty()) {
            throw new GradleException("Expected image 'project-scenario9-app:tested' not found!")
        }
        logger.lifecycle("SUCCESS: Image 'project-scenario9-app:tested' found with ID: ${imageId}")
        logger.lifecycle("Configuration cache test completed - check Gradle output for cache reuse")
    }
}

// =============================================================================
// Cleanup Task
// =============================================================================
tasks.register('cleanupProject') {
    description = 'Clean up Docker resources from dockerProject test'
    group = 'verification'

    doLast {
        def runCommand = { List<String> cmd ->
            try {
                def process = new ProcessBuilder(cmd).redirectErrorStream(true).start()
                process.inputStream.text
                process.waitFor()
            } catch (Exception e) {
                logger.debug("Command failed (ignored): ${cmd.join(' ')}: ${e.message}")
            }
        }

        // Remove test containers
        runCommand(['docker', 'compose', '-p', 'project-scenario9-test', 'down', '-v'])

        // Remove test images
        ['latest', 'tested'].each { tag ->
            runCommand(['docker', 'rmi', "project-scenario9-app:${tag}"])
        }
    }
}
