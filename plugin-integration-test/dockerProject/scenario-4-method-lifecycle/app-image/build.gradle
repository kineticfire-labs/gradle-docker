/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * dockerProject Integration Test: Scenario 4 - Method Lifecycle
 *
 * This scenario demonstrates the simplified dockerProject DSL with method lifecycle mode,
 * where containers are started fresh before each test method and stopped after each test.
 *
 * What this tests:
 * - dockerProject single-block configuration with lifecycle='method'
 * - jarFrom property for JAR-based builds
 * - test block with compose, waitForHealthy, and lifecycle='method'
 * - @ComposeUp annotation for Spock tests (method-level container management)
 * - Automatic translation to docker/dockerTest/dockerWorkflows DSLs
 *
 * Key characteristics of METHOD lifecycle:
 * - Containers start fresh before each test method
 * - Containers stop after each test method
 * - Each test method gets isolated container state
 * - Test framework extension (@ComposeUp) handles container lifecycle
 * - CRITICAL: maxParallelForks must be 1 to avoid port conflicts
 *
 * Port allocation (per README conventions):
 * - Service: 9303 (dockerProject scenario 4)
 */

plugins {
    id 'groovy'
    id 'com.kineticfire.gradle.docker'
}

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    testImplementation libs.groovy.all
    testImplementation libs.spock.core
    testRuntimeOnly libs.junit.platform.launcher
}

// =============================================================================
// DOCKER PROJECT DSL: Method Lifecycle Configuration
// =============================================================================
// This demonstrates the dockerProject DSL with lifecycle='method' which causes
// containers to be started/stopped for each test method (test isolation).
dockerProject {
    // images block: Define Docker images to build (supports multiple images)
    images {
        // Named block 'scenario4App' - the block name is used internally for task naming
        // Single image is automatically primary (receives onSuccess.additionalTags)
        scenario4App {
            // Required: Image name (must be unique across integration tests)
            imageName.set('project-scenario4-app')

            // Tags to apply to the built image
            tags.set(['latest', '1.0.0'])

            // jarFrom: Reference a task that produces a JAR file
            // The JAR will be copied to the build context as 'app.jar'
            jarFrom.set(':app:jar')

            // Build arguments and labels for the Docker image
            buildArgs.put('BUILD_VERSION', '1.0.0')
            labels.put('org.opencontainers.image.title', 'Project Scenario 4 - Method Lifecycle')
        }
    }

    // test block: Configure Docker Compose stack with METHOD lifecycle
    test {
        // Path to the Docker Compose file
        compose.set('src/integrationTest/resources/compose/app.yml')

        // Services to wait for HEALTHY status before running tests
        waitForHealthy.set(['app'])

        // Timeout for health checks (default: 60)
        timeoutSeconds.set(60)

        // KEY: Use METHOD lifecycle for test isolation
        // Containers will start fresh before each test method and stop after
        // The @ComposeUp annotation on the test class handles this
        lifecycle.set(com.kineticfire.gradle.docker.Lifecycle.METHOD)

        // Test task to execute (default: 'integrationTest')
        testTaskName.set('integrationTest')
    }

    // onSuccess block: Actions when tests pass
    onSuccess {
        // Additional tags to apply when tests succeed
        additionalTags.set(['tested'])
    }
}

// =============================================================================
// Integration Test Dependencies
// =============================================================================
dependencies {
    integrationTestImplementation files("${rootProject.projectDir}/buildSrc/build/classes/groovy/main")
    integrationTestImplementation libs.groovy.all
    integrationTestImplementation libs.spock.core
    integrationTestImplementation libs.rest.assured
    integrationTestImplementation libs.rest.assured.json.path
    integrationTestRuntimeOnly libs.junit.platform.launcher

    // Add plugin classes for @ComposeUp annotation access
    integrationTestImplementation "com.kineticfire.gradle:gradle-docker:${project.findProperty('plugin_version')}"
}

// Configure integration test task with system properties
afterEvaluate {
    tasks.named('integrationTest') {
        // CRITICAL: METHOD lifecycle requires sequential test execution
        // to avoid port conflicts when containers are started per method
        maxParallelForks = 1

        systemProperty 'COMPOSE_PROJECT_NAME', 'project-scenario4-test'
        systemProperty 'IMAGE_NAME', 'project-scenario4-app'
    }
}

// =============================================================================
// Task Orchestration
// =============================================================================
// Ensure proper task dependencies for pipeline execution
afterEvaluate {
    tasks.named('composeUpProjectscenario4appTest') {
        dependsOn tasks.named('dockerBuildProjectscenario4app')
        dependsOn project(':app').tasks.named('jar')
    }

    // For METHOD lifecycle, the test framework handles compose lifecycle
    // We only need the image built before tests run
    tasks.named('integrationTest') {
        dependsOn tasks.named('dockerBuildProjectscenario4app')
    }

    // Ensure pipeline has all required dependencies:
    // 1. Context preparation (copies JAR and Dockerfile to build context)
    // 2. Integration test classes compilation
    tasks.named('runProjectscenario4appPipeline') {
        dependsOn tasks.named('prepareProjectscenario4appContext')
        dependsOn tasks.named('integrationTestClasses')
    }
}

// =============================================================================
// Verification Task: Run the full pipeline and verify results
// =============================================================================
tasks.register('runProjectIntegrationTest') {
    description = 'Run the dockerProject method lifecycle pipeline and verify results'
    group = 'verification'

    // Ensure JAR is built first
    dependsOn project(':app').tasks.named('jar')

    // Run the pipeline (task name is 'run<ImageName>Pipeline')
    dependsOn tasks.named('runProjectscenario4appPipeline')

    doLast {
        // Verify the 'tested' tag was applied
        def process = new ProcessBuilder('docker', 'images', '-q', 'project-scenario4-app:tested')
            .redirectErrorStream(true)
            .start()
        def imageId = process.inputStream.text.trim()
        def exitCode = process.waitFor()

        if (exitCode != 0 || imageId.isEmpty()) {
            throw new GradleException("Expected image 'project-scenario4-app:tested' not found! " +
                "The onSuccess additionalTags may not have been applied.")
        }
        logger.lifecycle("SUCCESS: Image 'project-scenario4-app:tested' found with ID: ${imageId}")
    }
}

// Cleanup task
tasks.register('cleanupProject') {
    description = 'Clean up Docker resources from dockerProject test'
    group = 'verification'

    doLast {
        def runCommand = { List<String> cmd ->
            try {
                def process = new ProcessBuilder(cmd).redirectErrorStream(true).start()
                process.inputStream.text
                process.waitFor()
            } catch (Exception e) {
                logger.debug("Command failed (ignored): ${cmd.join(' ')}: ${e.message}")
            }
        }

        // Remove test containers (may already be down from test framework)
        runCommand(['docker', 'compose', '-p', 'project-scenario4-test', 'down', '-v'])

        // Remove test images
        ['latest', '1.0.0', 'tested'].each { tag ->
            runCommand(['docker', 'rmi', "project-scenario4-app:${tag}"])
        }
    }
}
