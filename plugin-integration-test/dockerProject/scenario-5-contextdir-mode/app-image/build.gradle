/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * dockerProject Integration Test: Scenario 5 - ContextDir Mode
 *
 * This scenario demonstrates the simplified dockerProject DSL with contextDir mode,
 * where the Docker build context is a pre-existing directory containing the Dockerfile
 * and all required files.
 *
 * What this tests:
 * - dockerProject single-block configuration with contextDir
 * - Pre-existing Docker context directory (vs jarFrom auto-generation)
 * - test block with compose and waitForHealthy
 * - Automatic translation to docker/dockerTest/dockerWorkflows DSLs
 *
 * Key differences from jarFrom mode:
 * - contextDir: User provides a directory containing Dockerfile and all files
 * - jarFrom: Plugin auto-generates context from Dockerfile + JAR task output
 *
 * Use contextDir when:
 * - You have a pre-existing Docker context with custom files
 * - You need more control over the build context layout
 * - You have non-JAR artifacts or multiple files to include
 *
 * Port allocation (per README conventions):
 * - Service: 9304 (dockerProject scenario 5)
 */

plugins {
    id 'groovy'
    id 'com.kineticfire.gradle.docker'
}

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    testImplementation libs.groovy.all
    testImplementation libs.spock.core
    testRuntimeOnly libs.junit.platform.launcher
}

// =============================================================================
// PREPARE DOCKER CONTEXT
// =============================================================================
// For contextDir mode, we need to prepare the context directory before building.
// This task copies the JAR to the pre-existing context directory.
def jarFileProvider = project(':app').tasks.named('jar').flatMap { it.archiveFile }

tasks.register('prepareContext', Copy) {
    group = 'docker'
    description = 'Prepare Docker context directory with application JAR'
    
    // Copy JAR from app project to context directory
    from(jarFileProvider) {
        rename { 'app.jar' }
    }
    into('src/main/docker-context')
    
    dependsOn project(':app').tasks.named('jar')
}

// =============================================================================
// DOCKER PROJECT DSL: ContextDir Mode Configuration
// =============================================================================
// This demonstrates the dockerProject DSL with contextDir which uses a
// pre-existing directory as the Docker build context.
dockerProject {
    // images block: Define Docker images to build (supports multiple images)
    images {
        // Named block 'scenario5App' - the block name is used internally for task naming
        // Single image is automatically primary (receives onSuccess.additionalTags)
        scenario5App {
            // Required: Image name (must be unique across integration tests)
            imageName.set('project-scenario5-app')

            // Tags to apply to the built image
            tags.set(['latest', '1.0.0'])

            // contextDir: Path to a pre-existing Docker context directory
            // This directory must contain:
            // - Dockerfile (or specify dockerfile property for custom name/path)
            // - All files needed for the Docker build
            contextDir.set('src/main/docker-context')

            // Build arguments and labels for the Docker image
            buildArgs.put('BUILD_VERSION', '1.0.0')
            labels.put('org.opencontainers.image.title', 'Project Scenario 5 - ContextDir Mode')
        }
    }

    // test block: Configure Docker Compose testing
    test {
        // Path to the Docker Compose file
        compose.set('src/integrationTest/resources/compose/app.yml')

        // Services to wait for HEALTHY status before running tests
        waitForHealthy.set(['app'])

        // Timeout for health checks (default: 60)
        timeoutSeconds.set(60)

        // Test task to execute (default: 'integrationTest')
        testTaskName.set('integrationTest')
    }

    // onSuccess block: Actions when tests pass
    onSuccess {
        // Additional tags to apply when tests succeed
        additionalTags.set(['tested'])
    }
}

// =============================================================================
// Integration Test Dependencies
// =============================================================================
dependencies {
    integrationTestImplementation files("${rootProject.projectDir}/buildSrc/build/classes/groovy/main")
    integrationTestImplementation libs.groovy.all
    integrationTestImplementation libs.spock.core
    integrationTestImplementation libs.rest.assured
    integrationTestImplementation libs.rest.assured.json.path
    integrationTestRuntimeOnly libs.junit.platform.launcher
}

// Configure integration test task with system properties
afterEvaluate {
    tasks.named('integrationTest') {
        systemProperty 'COMPOSE_PROJECT_NAME', 'project-scenario5-test'
        systemProperty 'IMAGE_NAME', 'project-scenario5-app'
    }

    // Ensure context is prepared before Docker build
    tasks.named('dockerBuildProjectscenario5app') {
        dependsOn tasks.named('prepareContext')
    }

    // Ensure composeUp depends on Docker build
    tasks.named('composeUpProjectscenario5appTest') {
        dependsOn tasks.named('dockerBuildProjectscenario5app')
    }

    // Ensure integrationTest depends on compose
    tasks.named('integrationTest') {
        dependsOn tasks.named('composeUpProjectscenario5appTest')
        finalizedBy tasks.named('composeDownProjectscenario5appTest')
    }
}

// =============================================================================
// Cleanup task
// =============================================================================
tasks.register('cleanupProject') {
    description = 'Clean up Docker resources from dockerProject test'
    group = 'verification'

    doLast {
        def runCommand = { List<String> cmd ->
            try {
                def process = new ProcessBuilder(cmd).redirectErrorStream(true).start()
                process.inputStream.text
                process.waitFor()
            } catch (Exception e) {
                logger.debug("Command failed (ignored): ${cmd.join(' ')}: ${e.message}")
            }
        }

        // Remove test containers
        runCommand(['docker', 'compose', '-p', 'project-scenario5-test', 'down', '-v'])

        // Remove test images
        ['latest', '1.0.0', 'tested'].each { tag ->
            runCommand(['docker', 'rmi', "project-scenario5-app:${tag}"])
        }
    }
}

// Clean up the copied JAR from context directory
tasks.named('clean') {
    doLast {
        delete 'src/main/docker-context/app.jar'
    }
}
