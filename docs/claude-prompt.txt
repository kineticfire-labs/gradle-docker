You are Principal Software Engineer and expert at Java, Gradle, custom Gradle plugins, Groovy, Docker, and Docker
Compose.  You are on a team building a custom Gradle plugin to build, tag, save, publish, and test Docker images. Read
the @CLAUDE.md file to understand the project and follow the guidelines exactly.  All of your code must be compatible
with Gradle 9 and 10 (especially the configuration build cache) per @docs/design-docs/gradle-9-and-10-compatibility.md .


./gradlew -Pplugin_version=1.0.0 clean build publishToMavenLocal

./gradlew -Pplugin_version=1.0.0 cleanAll integrationTest


For the implementation plan in @docs/design-docs/todo/add-method-lifecycle-workflow/add-method-workflow-analysis.md : implement Phase 1, Step 1.

## wait for logs

You are Principal Software Engineer and expert at Java, Gradle, custom Gradle plugins, Groovy, Docker, and Docker
  Compose.  You are on a team building a custom Gradle plugin to build, tag, save, publish, and test Docker images. Read
  the @CLAUDE.md file to understand the project and follow the guidelines exactly.  All of your code must be compatible
  with Gradle 9 and 10 (especially the configuration build cache) per @docs/design-docs/gradle-9-and-10-compatibility.md .

  Design an approach for 'dockerOrch' integration tests to wait for a specific message in the docker container logs to occur before determining that the container is ready to being testing.

  The current 'dockerOrch' accepts a 'waitForRunning' for 1 or more containers must be ready and/or 'waitForHealthy' where one or more containers must be healthy (as determined by the containers'
  health checks) before the integration tests are executed.


  waitForHealthy {
                  waitForServices.set(['isolated-tests'])
                  timeoutSeconds.set(60)
                  pollSeconds.set(2)
              }


## Unit Tests

You are Principal Software Engineer and expert at Java, Gradle, custom Gradle plugins, Groovy, Docker, and Docker
Compose.  You are on a team building a custom Gradle plugin to build, tag, save, publish, and test Docker images. Read
the @CLAUDE.md file to understand the project and follow the guidelines exactly.  You must add unit tests for the "com.kineticfire.gradle.docker" package because
the project goal is 100% instruction and branch unit test coverage but this package falls short.  Analyze the source implementation, then inspect the unit tests, then:
- identify functions that are not unit tested that can be without complex mocks
- identify functions that are not fully tested that can be without complex mocks
- identify functions whose inputs are not fully tested, such as edge cases (null, 0, exceptions, etc)
- generally identify functions where additional unit tests can be added without complex mocks

Note that the unit tests require about 8 to 12 minutes to run, so set your timeouts accordingly.  Consider running targeted unit tests first against only the
code you changed then run the full test suite at the end.

Analyze, develop a plan, then implement.  Acceptance criteria is all tests pass and the plugin builds.  Go!

### Unit Test Challenge Package
This package may be challenging to unit test since it makes external calls to 'docker' and 'docker compose'.  Test the code that does not require mocks or the code
that does not require complex mocks.  Consider how code could be refactored to push external calls to the smallest functions (by code and branch size) possible
to increase unit test coverage without mocks or complex mocks.

## Unit Tests - refactor

You are Principal Software Engineer and expert at Java, Gradle, custom Gradle plugins, Groovy, Docker, and Docker
  Compose.  You are on a team building a custom Gradle plugin to build, tag, save, publish, and test Docker images. Read
  the @CLAUDE.md file to understand the project and follow the guidelines exactly.  All of your code must be compatible
  with Gradle 9 and 10 (especially the configuration build cache) per @docs/design-docs/gradle-9-and-10-compatibility.md .

  Your task is to identify how the plugin source code at @plugin/src/main/ could be refactored to increase unit test coverage for the com.kineticfire.gradle.docker package.  Analyze
  the source code, determine how the code can be changed to increase test coverage without using complex mocks such as moving external calls to functions with minimal code thus
  allowing testing of other code that is not making external calls.  Study the code base and determine how it could best be shaped to allow for greater unit test coverage.

  All changes must be compatible with Gradle 9 and 10, especially the build cache configuration, per at @docs/design-docs/gradle-9-and-10-compatibility.md .

  Present your findings and recommendations.



## Exploring dockerOrch

You are Principal Software Engineer and expert at Java, Gradle, custom Gradle plugins, Groovy, Docker, and Docker
Compose.  You are on a team building a custom Gradle plugin to build, tag, save, publish, and test Docker images. Read
the @CLAUDE.md file to understand the project and follow the guidelines exactly.

The goal of this project is to (1) build a new container or reference a pre-existing Linux image then (2) test that
image by creating a container (or more) and running tests against it.  The mantra is that we should test exactly what
we deliver.

It is envisioned that we will be testing:
(1) primarily web services, such as HTTP.  But it could be any remote service like SSH, telnet, ftp, database connections, etc.
(2) or any "service" provided by a container, which could be simply exec-ing a command getting output or having the container
output data to the container or host filesystem

In all of those cases above, this plugin needs to provide the means to enable that testing.

The testing approach is generally:
1. Get a reference to an image, which could be build a new image or reference a pre-existing image
2. Start the image using 'docker compose' on a Docker Compose file.  This makes it easier to start and stop the image and
also start and stop groups of images if the container under test depends on other containers running.  This also enables
"system" type testing.
3. Wait for the container or groups of containers to be ready before starting the tests.  Ready could mean 'RUNNING'
were the container has hit that state, or 'HEALTHY' were the container health check has indicated it is healthy (if it
has a health check).
   1. We must allow waiting for groups of containers to be ready for testing, were some containers will have health
   checks and others will not.  So this needs to be configurable to say "I have these containers, wait for this set to be
   'RUNNING' and this set to be 'HEALTHY' then say the containers are ready for testing."
4. We need to then execute the tests.  Tests should be able to be written in Groovy or Java or both.
5. Tests need to be run against a known and controlled container (or group thereof) under test
   1. Some containers may be able to be spun-up once and have all tests run against them, without reseting the container
   between tests
   2. Some containers (or maybe types of test) may require the container to be reset (so it's at a known-good state) before
   the next test
   3. We can think of these as lifecycle tests: create and use for the test suite, the class, or the method
6. We need good clean-up of containers after tests finish and especially if errors occur, so that there aren't dangling
containers which can impact other tests and be a chore for the user to manually clean-up
7. We need good output to tell the user what's happening, and especially error output to tell the user why a test failed;
ideally, logs would be good and centralizing those for ease of use

This project defined the recommended Directory Layout as follows:

```
the-application-project/                  # a project that (1) builds an application and tests it, and (2) puts the
│                                           application in a Linux image and tests the unit of delivery by spinning up
│                                           the container and testing it
├─ app/                                   # builds the application, such as a JAR (or other artifact)
│  ├─ build.gradle
│  └─ src/
│     ├─ main/java/...
│     └─ test/java/...
└─ app-image/                              # builds the Linux image + tests it
   ├─ build.gradle
   ├─ src/
   │  ├─ main/docker/                      # Dockerfile + build assets (image context)
   │  │  ├─ Dockerfile
   │  │  └─ ...                            # scripts, config, .dockerignore, etc.
   │  ├─ integrationTest/groovy/           # Groovy/Spock integration tests
   │  ├─ integrationTest/java/             # Java/JUnit integration tests
   │  ├─ integrationTest/resources/
   │  │  ├─ compose/                       # compose files for integration tests
   │  │  └─ docker/                        # optional: test-only wrapper image assets
   │  └─ testFixtures/                     # (optional) shared test helpers/utilities
   ├─ docs/                                # (optional) runbooks, diagrams for tests
   └─ build/                               # outputs: transcripts, logs, saved tars, state JSON, etc.
      ├─ docker/                           # image tars (from dockerSave*)
      ├─ compose-logs/                     # compose logs by task/suite
      └─ compose/                          # compose state files (JSON) per stack
```

In many projects, the Dockerfile is just a file within the application build and even at the top-level.  This project
explicitly makes the Dockerfile (really, the image build/reference and testing) a separate project from the application
build (e.g., a JAR file) is for Separation of Concerns.  With the testing applied by the plugin, the project is larger,
 there are more parts (image build, tests, logs/output, etc) and it is better to separate those.

The approach the project has taken for implementation is:
- the `docker` Gradle DSL task handles the image:  build or reference, tag, save, and publish
- the `dockerOrch` Gradle DSL task handle the testing of the image

The implementation for the `docker` task is completed and is located in @plugin/src/main .  Understand how the plugin
is applied through its integration tests @plugin-integration-test (although note that the 'app' project is not a peer
to the integration tests in this case so it can be re-used across the tests so it doesn't have to be duplicated).

The implementation for the `dockerOrch` task is located in @plugin/src/main .  Integration tests were started for the
`dockerOrch` task, however these are not very good and mostly ended up being more like functional tests.  The best
example for what these integration tests SHOULD be and how this task should work is at @old-plugin-integration-test/build.gradle
lines 184 to 219 which show the lifecycle tests (integrationSuite, integrationClass, integrationMethod).

I want you to evaluate the current state of the code supporting image testing using `dockerOrch` task and report your findings.
- Is the approach sound?
- Does the implementation support the stated project goals and approach?
- What is the state of the implementation (done or more work to do)?
- Is there sufficient unit test coverage?
- Recommendations?
- What is needed to have this implementation done and production ready, to support writing final integration tests?

Analyze and report only, do NOT edit files.




## Integration Tests

  You are Principal Software Engineer and expert at Java, Gradle, custom Gradle plugins, Groovy, Docker, and Docker
    Compose.  You are on a team building a custom Gradle plugin to build, tag, save, publish, and test Docker images. Read
    the @CLAUDE.md file to understand the project and follow the guidelines exactly.

    You will write a specific, new integration test to test and prove and demonstrate aspects of the plugin.  Your integration test must be compatible with Gradle and 10, especially
    the build cache configuration, per @docs/design-docs/gradle-9-and-10-compatibility.md .

    Your integration test will cover aspects related to 'docker' DSL task so functionality like: build, tag, save, and publish.  Analyze the existing integration tests for the
    'docker' DSL tasks in @plugin-integration-test/docker/ .  Understand usage for the 'docker' DSL task at @docs/usage/usage-docker.md .  Understand and use the common integration
    test capabilities in the buildSrc at @plugin-integration-test/buildSrc/ .

    Your task is to write a new integration test, called 'scenario-99' at @plugin-integration-test/docker/scenario-99/ , that must provide an integration test using a build.gradle
  file
    for these aspects:
  - The goal of the integration is to test publish an image to Docker Hub, so the integration test will have a 'publish' task
  - We will use environment variable 'DOCKERHUB_USERNAME' for the username and environment variable 'DOCKERHUB_TOKEN' for the token, so that we don't commit these credentials to the
  git repository
  - The image we will publish will be our TimeServer app and name the image 'time-server'
  - We need to think about these aspects:
     - If we hardcode the image tag as 'latest' or '1.0.0', then we can't re-run the integration test because that image will already exist.  Perhaps we could set the tag as a
     datetimestamp based on zulu time?
     - I assume we can create a private repository in Docker Hub, so that these test images won't be public?
     - The repository name should be: kineticfire/gradle-docker/test/ ?
     - We don't want this integration test to run with the other integration tests because:
        - This test requires special authentication information in the form of env vars
        - We don't want to fill up the repository with a bunch of test images.  Run only when needed.

  Acceptance criteria is that the integration test passes.

  Can you consider these aspects and suggest how to create this integration test for Docker Hub?  We will likely repeat
  this approach with other public repositories, so it needs to be a solid and repeatable approach.  Plan only,
  do NOT update any files.



