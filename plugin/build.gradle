/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * KineticFire Labs: https://labs.kineticfire.com/
 *     project site: https://github.com/kineticfire-labs/gradle-docker/
 */

import org.gradle.api.DefaultTask
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.TaskAction

plugins {
    alias(libs.plugins.groovy)
    alias(libs.plugins.javaGradlePlugin)
    alias(libs.plugins.maven.publish)
    alias(libs.plugins.gradle.plugin.publish)
    alias(libs.plugins.jacoco)
    alias(libs.plugins.palantir.idea.test.fix)
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories {
    mavenCentral()
    gradlePluginPortal()
}

dependencies {
    // Docker Java Client
    implementation libs.docker.java.core
    implementation libs.docker.java.transport.httpclient5
    
    // exec library for Docker Compose (placeholder - will implement in Phase 2)
    // implementation 'com.kineticfire.labs:exec:1.0.0'
    
    // JSON processing
    implementation libs.jackson.core
    implementation libs.jackson.databind
    
    // Compression libraries
    implementation libs.commons.compress
    
    // JUnit 5 for lifecycle extensions (provided as implementation for downstream consumers)
    implementation libs.junit.jupiter.api
    
    // Gradle API
    compileOnly gradleApi()
    compileOnly localGroovy()
    
    // Testing
    testImplementation platform(libs.spock.bom)
    testImplementation libs.spock.core
    testImplementation libs.spock.junit4
    testRuntimeOnly libs.junit.platform.launcher
    testRuntimeOnly libs.junit.platform.engine
    testRuntimeOnly libs.junit.vintage.engine
    testImplementation gradleTestKit()
    testImplementation libs.junit4
}

group = 'com.kineticfire.gradle'
version = '1.0.0'  // todo: not used?

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}


gradlePlugin {
    website = 'https://github.com/kineticfire-labs/gradle-docker'
    vcsUrl = 'https://github.com/kineticfire-labs/gradle-docker'
    
    plugins {
        gradleDockerPlugin {
            id = 'com.kineticfire.gradle.gradle-docker'
            implementationClass = 'com.kineticfire.gradle.docker.GradleDockerPlugin'
            displayName = 'Gradle Docker Plugin'
            description = 'Provides Docker image build/publish and Compose orchestration for Gradle projects'
            tags = ['docker', 'containers', 'docker-compose', 'testing']
        }
    }
}

jar {
    archiveBaseName = 'gradle-docker'

    manifest {
        attributes(
                'Implementation-Title': project.name,
                'Implementation-Version': project.version,
                'Implementation-Vendor': 'KineticFire Labs'
        )
    }

    // Reproducible builds
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

// Configure functional test source set manually to work around TestKit issues
sourceSets {
    functionalTest {
        groovy.srcDir 'src/functionalTest/groovy'
        resources.srcDir 'src/functionalTest/resources'
        compileClasspath += sourceSets.main.output
        runtimeClasspath += output + compileClasspath
    }
}

configurations {
    functionalTestImplementation.extendsFrom implementation
    functionalTestRuntimeOnly.extendsFrom runtimeOnly
}

dependencies {
    // Functional testing dependencies
    functionalTestImplementation platform(libs.spock.bom)
    functionalTestImplementation libs.spock.core
    functionalTestImplementation gradleTestKit()
    functionalTestRuntimeOnly libs.junit.platform.launcher
    functionalTestRuntimeOnly libs.junit.vintage.engine
}

jacocoTestReport {
    reports {
        xml.required = true // Enable XML report generation
        html.required = true // Ensure HTML report is also generated
    }
    // Ensure tests run before report generation
    dependsOn test
}

// This configuration is moved to after coverageSummary task registration below

abstract class CoverageSummaryTask extends DefaultTask {
    
    @InputFile
    abstract RegularFileProperty getReportFile()
    
    @InputFile  
    abstract RegularFileProperty getHtmlReportFile()
    
    @TaskAction
    void generateSummary() {
        def reportFile = getReportFile().asFile.get()
        def htmlReportPath = getHtmlReportFile().asFile.get().absolutePath
        
        if (!reportFile.exists()) {
            println "JaCoCo XML report not found. Run tests first."
            return
        }
        
        def parser = new groovy.xml.XmlSlurper()
        parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
        parser.setFeature("http://xml.org/sax/features/external-general-entities", false)
        parser.setFeature("http://xml.org/sax/features/external-parameter-entities", false)
        parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
        System.setProperty("javax.xml.accessExternalDTD", "all")
        def root = parser.parse(reportFile)
        
        println "\n" + "="*80
        println "TEST COVERAGE SUMMARY"
        println "="*80
        
        // Overall totals
        def totalInstr = root.counter.find { it.@type == 'INSTRUCTION' }
        def totalBranch = root.counter.find { it.@type == 'BRANCH' }
        def totalLine = root.counter.find { it.@type == 'LINE' }
        def totalMethod = root.counter.find { it.@type == 'METHOD' }
        def totalClass = root.counter.find { it.@type == 'CLASS' }
        
        if (totalInstr) {
            def instrCovered = Integer.parseInt(totalInstr.@covered.toString())
            def instrMissed = Integer.parseInt(totalInstr.@missed.toString())
            def instrTotal = instrCovered + instrMissed
            def instrPercent = instrTotal > 0 ? String.format("%.1f", (instrCovered * 100.0 / instrTotal)) : "0.0"
            
            def branchCovered = totalBranch ? Integer.parseInt(totalBranch.@covered.toString()) : 0
            def branchMissed = totalBranch ? Integer.parseInt(totalBranch.@missed.toString()) : 0
            def branchTotal = branchCovered + branchMissed
            def branchPercent = branchTotal > 0 ? String.format("%.1f", (branchCovered * 100.0 / branchTotal)) : "n/a"
            
            def lineCovered = totalLine ? Integer.parseInt(totalLine.@covered.toString()) : 0
            def lineMissed = totalLine ? Integer.parseInt(totalLine.@missed.toString()) : 0
            def lineTotal = lineCovered + lineMissed
            def linePercent = lineTotal > 0 ? String.format("%.1f", (lineCovered * 100.0 / lineTotal)) : "0.0"
            
            def methodCovered = totalMethod ? Integer.parseInt(totalMethod.@covered.toString()) : 0
            def methodMissed = totalMethod ? Integer.parseInt(totalMethod.@missed.toString()) : 0
            def methodTotal = methodCovered + methodMissed
            def methodPercent = methodTotal > 0 ? String.format("%.1f", (methodCovered * 100.0 / methodTotal)) : "0.0"
            
            def classCovered = totalClass ? Integer.parseInt(totalClass.@covered.toString()) : 0
            def classMissed = totalClass ? Integer.parseInt(totalClass.@missed.toString()) : 0
            def classTotal = classCovered + classMissed
            def classPercent = classTotal > 0 ? String.format("%.1f", (classCovered * 100.0 / classTotal)) : "0.0"
            
            println "OVERALL PROJECT COVERAGE:"
            println String.format("  Instructions: %s%% (%,d/%,d)", instrPercent, instrCovered, instrTotal)
            println String.format("  Branches:     %s%% (%,d/%,d)", branchPercent, branchCovered, branchTotal)
            println String.format("  Lines:        %s%% (%,d/%,d)", linePercent, lineCovered, lineTotal)
            println String.format("  Methods:      %s%% (%,d/%,d)", methodPercent, methodCovered, methodTotal)
            println String.format("  Classes:      %s%% (%,d/%,d)", classPercent, classCovered, classTotal)
            println ""
        }
        
        // Package-level breakdown
        println "COVERAGE BY PACKAGE:"
        println String.format("%-50s %12s %12s", "Package", "Instructions", "Branches")
        println "-" * 80
        
        root.package.each { pkg ->
            def pkgName = pkg.@name.toString().replace('/', '.')
            if (pkgName.isEmpty()) pkgName = "(default)"
            
            def pkgInstr = pkg.counter.find { it.@type == 'INSTRUCTION' }
            def pkgBranch = pkg.counter.find { it.@type == 'BRANCH' }
            
            def instrCovered = pkgInstr ? Integer.parseInt(pkgInstr.@covered.toString()) : 0
            def instrMissed = pkgInstr ? Integer.parseInt(pkgInstr.@missed.toString()) : 0
            def instrTotal = instrCovered + instrMissed
            def instrPercent = instrTotal > 0 ? String.format("%.1f%%", (instrCovered * 100.0 / instrTotal)) : "n/a"
            
            def branchCovered = pkgBranch ? Integer.parseInt(pkgBranch.@covered.toString()) : 0
            def branchMissed = pkgBranch ? Integer.parseInt(pkgBranch.@missed.toString()) : 0
            def branchTotal = branchCovered + branchMissed
            def branchPercent = branchTotal > 0 ? String.format("%.1f%%", (branchCovered * 100.0 / branchTotal)) : "n/a"
            
            println String.format("%-50s %12s %12s", pkgName, instrPercent, branchPercent)
        }
        
        println ""
        println "HTML REPORT:"
        println "file://" + htmlReportPath
        println ""
        println "="*80
    }
}

tasks.register('coverageSummary', CoverageSummaryTask) {
    description = 'Displays test coverage summary and HTML report link'
    group = 'reporting'
    dependsOn jacocoTestReport
    
    reportFile = layout.buildDirectory.file("reports/jacoco/test/jacocoTestReport.xml")
    htmlReportFile = layout.buildDirectory.file("reports/jacoco/test/html/index.html")
}

// Configure test task to run coverage summary after tests complete
tasks.test {
    finalizedBy(tasks.jacocoTestReport, tasks.coverageSummary) // Report and summary are always generated after tests run
}

tasks.register('functionalTest', Test) {
    description = 'Runs functional tests'
    group = 'verification'

    testClassesDirs = sourceSets.functionalTest.output.classesDirs
    classpath = sourceSets.functionalTest.runtimeClasspath
    useJUnitPlatform()

    dependsOn tasks.pluginUnderTestMetadata

    // Disable configuration cache for functional tests to work around TestKit service cleanup issues
    // See docs/design-docs/tech-debt/functional-tests-config-cache-disabled.md
    doNotTrackState("Functional tests use TestKit which has configuration cache conflicts")
    notCompatibleWithConfigurationCache("TestKit service cleanup conflicts with configuration cache")

    // TestKit compatibility flags for Gradle 9.0.0
    // These flags are required for functional tests but don't affect the main build
    systemProperty 'org.gradle.testkit.dir', project.file('build/testkit')
    jvmArgs '-Dorg.gradle.daemon.idletimeout=1000'
    jvmArgs '-Dorg.gradle.unsafe.configuration-cache=false'
    jvmArgs '-Dorg.gradle.parallel=false'
    
    // Force sequential execution to avoid race conditions
    maxParallelForks = 1
    
    // Ensure TestKit uses the correct flags when running nested Gradle builds
    environment 'GRADLE_OPTS', '--no-daemon --no-parallel --no-configuration-cache'
}

// TEMPORARILY REMOVED: functionalTest dependency from check task
// Due to Gradle 9.0.0 TestKit compatibility issues, functional tests are disabled
// and marked as incompatible with configuration cache. Including them in the standard
// build flow causes configuration cache to be discarded for ALL tasks.
//
// To run functional tests manually: ./gradlew functionalTest
// See: docs/design-docs/functional-test-testkit-gradle-issue.md
//
// tasks.named('check') {
//     dependsOn tasks.functionalTest
// }

tasks.named('test') {
    // Use JUnit Platform for Spock tests
    useJUnitPlatform()
}

// Added so that tests can be excluded on the command line.  For example, DockerUtilsTest.groovy require a lot of time to run.  To exclude:
//    gradle clean test -PexcludeTests=**/*DockerUtilsTest*
test {
    if ( project.hasProperty( 'excludeTests' ) ) {
        exclude project.property( 'excludeTests' )
    }
}
