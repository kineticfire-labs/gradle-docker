/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * KineticFire Labs: https://labs.kineticfire.com/
 *     project site: https://github.com/kineticfire-labs/gradle-docker/
 */

import org.gradle.api.DefaultTask
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.TaskAction

plugins {
    id 'groovy'
    id 'java-gradle-plugin'
    id 'maven-publish'
    id 'com.gradle.plugin-publish' version '1.2.1'
    id 'jacoco'
    id 'com.palantir.idea-test-fix' version '0.1.0'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories {
    mavenCentral()
    gradlePluginPortal()
}

dependencies {
    // Docker Java Client
    implementation 'com.github.docker-java:docker-java-core:3.3.4'
    implementation 'com.github.docker-java:docker-java-transport-httpclient5:3.3.4'
    
    // exec library for Docker Compose (placeholder - will implement in Phase 2)
    // implementation 'com.kineticfire.labs:exec:1.0.0'
    
    // JSON processing
    implementation 'com.fasterxml.jackson.core:jackson-core:2.16.0'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.16.0'
    
    // JUnit 5 for lifecycle extensions (provided as implementation for downstream consumers)
    implementation 'org.junit.jupiter:junit-jupiter-api:5.10.1'
    
    // Gradle API
    compileOnly gradleApi()
    compileOnly localGroovy()
    
    // Testing
    testImplementation platform('org.spockframework:spock-bom:2.4-M4-groovy-4.0')
    testImplementation 'org.spockframework:spock-core'
    testImplementation 'org.spockframework:spock-junit4'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testRuntimeOnly 'org.junit.platform:junit-platform-engine'
    testRuntimeOnly 'org.junit.vintage:junit-vintage-engine'
    testImplementation gradleTestKit()
    testImplementation 'junit:junit:4.13.2'
    
    // Functional testing (will be configured by testing suites)
    // Note: functionalTest dependencies configured by testing.suites
}

group = 'com.kineticfire.gradle'
version = '1.0.0'  // todo: not used?

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}


gradlePlugin {
    website = 'https://github.com/kineticfire-labs/gradle-docker'
    vcsUrl = 'https://github.com/kineticfire-labs/gradle-docker'
    
    plugins {
        gradleDockerPlugin {
            id = 'com.kineticfire.gradle.gradle-docker'
            implementationClass = 'com.kineticfire.gradle.docker.GradleDockerPlugin'
            displayName = 'Gradle Docker Plugin'
            description = 'Provides Docker image build/publish and Compose orchestration for Gradle projects'
            tags = ['docker', 'containers', 'docker-compose', 'testing']
        }
    }
}

jar {
    archiveBaseName = 'gradle-docker'

    manifest {
        attributes(
                'Implementation-Title': project.name,
                'Implementation-Version': project.version,
                'Implementation-Vendor': 'KineticFire Labs'
        )
    }

    // Reproducible builds
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

// Configure functional test source set manually to work around TestKit issues
sourceSets {
    functionalTest {
        groovy.srcDir 'src/functionalTest/groovy'
        resources.srcDir 'src/functionalTest/resources'
        compileClasspath += sourceSets.main.output
        runtimeClasspath += output + compileClasspath
    }
}

configurations {
    functionalTestImplementation.extendsFrom implementation
    functionalTestRuntimeOnly.extendsFrom runtimeOnly
}

dependencies {
    functionalTestImplementation platform('org.spockframework:spock-bom:2.4-M4-groovy-4.0')
    functionalTestImplementation 'org.spockframework:spock-core'
    functionalTestImplementation gradleTestKit()
    functionalTestRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    functionalTestRuntimeOnly 'org.junit.vintage:junit-vintage-engine'
}

jacocoTestReport {
    reports {
        xml.required = true // Enable XML report generation
        html.required = true // Ensure HTML report is also generated
    }
    // Ensure tests run before report generation
    dependsOn test
}

// This configuration is moved to after coverageSummary task registration below

abstract class CoverageSummaryTask extends DefaultTask {
    
    @InputFile
    abstract RegularFileProperty getReportFile()
    
    @InputFile  
    abstract RegularFileProperty getHtmlReportFile()
    
    @TaskAction
    void generateSummary() {
        def reportFile = getReportFile().asFile.get()
        def htmlReportPath = getHtmlReportFile().asFile.get().absolutePath
        
        if (!reportFile.exists()) {
            println "JaCoCo XML report not found. Run tests first."
            return
        }
        
        def parser = new groovy.xml.XmlSlurper()
        parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
        parser.setFeature("http://xml.org/sax/features/external-general-entities", false)
        parser.setFeature("http://xml.org/sax/features/external-parameter-entities", false)
        parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
        System.setProperty("javax.xml.accessExternalDTD", "all")
        def root = parser.parse(reportFile)
        
        println "\n" + "="*80
        println "TEST COVERAGE SUMMARY"
        println "="*80
        
        // Overall totals
        def totalInstr = root.counter.find { it.@type == 'INSTRUCTION' }
        def totalBranch = root.counter.find { it.@type == 'BRANCH' }
        def totalLine = root.counter.find { it.@type == 'LINE' }
        def totalMethod = root.counter.find { it.@type == 'METHOD' }
        def totalClass = root.counter.find { it.@type == 'CLASS' }
        
        if (totalInstr) {
            def instrCovered = Integer.parseInt(totalInstr.@covered.toString())
            def instrMissed = Integer.parseInt(totalInstr.@missed.toString())
            def instrTotal = instrCovered + instrMissed
            def instrPercent = instrTotal > 0 ? String.format("%.1f", (instrCovered * 100.0 / instrTotal)) : "0.0"
            
            def branchCovered = totalBranch ? Integer.parseInt(totalBranch.@covered.toString()) : 0
            def branchMissed = totalBranch ? Integer.parseInt(totalBranch.@missed.toString()) : 0
            def branchTotal = branchCovered + branchMissed
            def branchPercent = branchTotal > 0 ? String.format("%.1f", (branchCovered * 100.0 / branchTotal)) : "n/a"
            
            def lineCovered = totalLine ? Integer.parseInt(totalLine.@covered.toString()) : 0
            def lineMissed = totalLine ? Integer.parseInt(totalLine.@missed.toString()) : 0
            def lineTotal = lineCovered + lineMissed
            def linePercent = lineTotal > 0 ? String.format("%.1f", (lineCovered * 100.0 / lineTotal)) : "0.0"
            
            def methodCovered = totalMethod ? Integer.parseInt(totalMethod.@covered.toString()) : 0
            def methodMissed = totalMethod ? Integer.parseInt(totalMethod.@missed.toString()) : 0
            def methodTotal = methodCovered + methodMissed
            def methodPercent = methodTotal > 0 ? String.format("%.1f", (methodCovered * 100.0 / methodTotal)) : "0.0"
            
            def classCovered = totalClass ? Integer.parseInt(totalClass.@covered.toString()) : 0
            def classMissed = totalClass ? Integer.parseInt(totalClass.@missed.toString()) : 0
            def classTotal = classCovered + classMissed
            def classPercent = classTotal > 0 ? String.format("%.1f", (classCovered * 100.0 / classTotal)) : "0.0"
            
            println "OVERALL PROJECT COVERAGE:"
            println String.format("  Instructions: %s%% (%,d/%,d)", instrPercent, instrCovered, instrTotal)
            println String.format("  Branches:     %s%% (%,d/%,d)", branchPercent, branchCovered, branchTotal)
            println String.format("  Lines:        %s%% (%,d/%,d)", linePercent, lineCovered, lineTotal)
            println String.format("  Methods:      %s%% (%,d/%,d)", methodPercent, methodCovered, methodTotal)
            println String.format("  Classes:      %s%% (%,d/%,d)", classPercent, classCovered, classTotal)
            println ""
        }
        
        // Package-level breakdown
        println "COVERAGE BY PACKAGE:"
        println String.format("%-50s %12s %12s", "Package", "Instructions", "Branches")
        println "-" * 80
        
        root.package.each { pkg ->
            def pkgName = pkg.@name.toString().replace('/', '.')
            if (pkgName.isEmpty()) pkgName = "(default)"
            
            def pkgInstr = pkg.counter.find { it.@type == 'INSTRUCTION' }
            def pkgBranch = pkg.counter.find { it.@type == 'BRANCH' }
            
            def instrCovered = pkgInstr ? Integer.parseInt(pkgInstr.@covered.toString()) : 0
            def instrMissed = pkgInstr ? Integer.parseInt(pkgInstr.@missed.toString()) : 0
            def instrTotal = instrCovered + instrMissed
            def instrPercent = instrTotal > 0 ? String.format("%.1f%%", (instrCovered * 100.0 / instrTotal)) : "n/a"
            
            def branchCovered = pkgBranch ? Integer.parseInt(pkgBranch.@covered.toString()) : 0
            def branchMissed = pkgBranch ? Integer.parseInt(pkgBranch.@missed.toString()) : 0
            def branchTotal = branchCovered + branchMissed
            def branchPercent = branchTotal > 0 ? String.format("%.1f%%", (branchCovered * 100.0 / branchTotal)) : "n/a"
            
            println String.format("%-50s %12s %12s", pkgName, instrPercent, branchPercent)
        }
        
        println ""
        println "HTML REPORT:"
        println "file://" + htmlReportPath
        println ""
        println "="*80
    }
}

tasks.register('coverageSummary', CoverageSummaryTask) {
    description = 'Displays test coverage summary and HTML report link'
    group = 'reporting'
    dependsOn jacocoTestReport
    
    reportFile = layout.buildDirectory.file("reports/jacoco/test/jacocoTestReport.xml")
    htmlReportFile = layout.buildDirectory.file("reports/jacoco/test/html/index.html")
}

// Configure test task to run coverage summary after tests complete
tasks.test {
    finalizedBy(tasks.jacocoTestReport, tasks.coverageSummary) // Report and summary are always generated after tests run
}

tasks.register('functionalTest', Test) {
    description = 'Runs functional tests'
    group = 'verification'
    
    testClassesDirs = sourceSets.functionalTest.output.classesDirs
    classpath = sourceSets.functionalTest.runtimeClasspath
    useJUnitPlatform()
    
    dependsOn tasks.pluginUnderTestMetadata
}

tasks.named('check') {
    dependsOn tasks.functionalTest
}

tasks.named('test') {
    // Use JUnit Platform for Spock tests
    useJUnitPlatform()
}

// Added so that tests can be excluded on the command line.  For example, DockerUtilsTest.groovy require a lot of time to run.  To exclude:
//    gradle clean test -PexcludeTests=**/*DockerUtilsTest*
test {
    if ( project.hasProperty( 'excludeTests' ) ) {
        exclude project.property( 'excludeTests' )
    }
}
