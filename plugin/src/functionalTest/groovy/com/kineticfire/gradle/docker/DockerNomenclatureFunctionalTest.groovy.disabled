/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.kineticfire.gradle.docker

import com.kineticfire.gradle.docker.model.SaveCompression
import org.gradle.testkit.runner.GradleRunner
import org.gradle.testkit.runner.TaskOutcome
import spock.lang.Specification
import spock.lang.TempDir

import java.nio.file.Path

/**
 * Functional tests for Docker nomenclature validation and dual-mode support
 * 
 * NOTE: These tests focus on configuration verification and validation rather than 
 * actual Docker execution due to TestKit limitations with Gradle 9. Real Docker 
 * operations are covered by integration tests in the plugin-integration-test project.
 */
class DockerNomenclatureFunctionalTest extends Specification {

    @TempDir
    Path testProjectDir

    File settingsFile
    File buildFile

    def setup() {
        settingsFile = testProjectDir.resolve('settings.gradle').toFile()
        buildFile = testProjectDir.resolve('build.gradle').toFile()
    }

    def "validates build mode requires either repository or imageName"() {
        given:
        settingsFile << "rootProject.name = 'test-build-validation'"
        
        buildFile << """
            plugins {
                id 'com.kineticfire.gradle.gradle-docker'
            }
            
            docker {
                images {
                    missingName {
                        // Build mode but missing both repository and imageName
                        registry.set('docker.io')
                        namespace.set('mycompany')
                        version.set('1.0.0')
                        tags.set(['latest'])
                        context.set(file('.'))
                    }
                }
            }
        """

        when:
        def result = GradleRunner.create()
            .withProjectDir(testProjectDir.toFile())
            .withPluginClasspath(System.getProperty("java.class.path").split(File.pathSeparator).collect { new File(it) })
            .withArguments('tasks', '--all')
            .buildAndFail()

        then:
        result.output.contains('must specify either') || result.output.contains('imageName') || result.output.contains('repository')
    }

    def "validates repository and namespace+imageName are mutually exclusive"() {
        given:
        settingsFile << "rootProject.name = 'test-mutual-exclusion'"
        
        buildFile << """
            plugins {
                id 'com.kineticfire.gradle.gradle-docker'
            }
            
            docker {
                images {
                    conflictingConfig {
                        // Both repository and namespace+imageName set
                        registry.set('docker.io')
                        repository.set('mycompany/my-app')
                        namespace.set('mycompany')
                        imageName.set('my-app')
                        version.set('1.0.0')
                        tags.set(['latest'])
                        context.set(file('.'))
                    }
                }
            }
        """

        when:
        def result = GradleRunner.create()
            .withProjectDir(testProjectDir.toFile())
            .withPluginClasspath(System.getProperty("java.class.path").split(File.pathSeparator).collect { new File(it) })
            .withArguments('tasks', '--all')
            .buildAndFail()

        then:
        result.output.contains('mutual exclusivity violation') || result.output.contains('cannot specify both')
    }

    def "validates sourceRef mode excludes build properties"() {
        given:
        settingsFile << "rootProject.name = 'test-sourceref-validation'"
        
        buildFile << """
            plugins {
                id 'com.kineticfire.gradle.gradle-docker'
            }
            
            docker {
                images {
                    invalidSourceRef {
                        // SourceRef mode with build properties (invalid)
                        sourceRef.set('ghcr.io/upstream/app:1.0.0')
                        
                        // These should be invalid with sourceRef
                        context.set(file('.'))
                        buildArgs.put('VERSION', '1.0.0')
                        labels.put('build.time', 'now')
                        
                        tags.set(['local:latest'])
                    }
                }
            }
        """

        when:
        def result = GradleRunner.create()
            .withProjectDir(testProjectDir.toFile())
            .withPluginClasspath(System.getProperty("java.class.path").split(File.pathSeparator).collect { new File(it) })
            .withArguments('tasks', '--all')
            .buildAndFail()

        then:
        // Should now properly validate and reject sourceRef + build properties combination
        result.output.contains('Cannot mix Build Mode and SourceRef Mode')
    }

    def "supports valid build mode configuration with namespace and imageName"() {
        given:
        settingsFile << "rootProject.name = 'test-valid-build-namespace'"
        
        buildFile << """
            plugins {
                id 'com.kineticfire.gradle.gradle-docker'
            }
            
            docker {
                images {
                    validBuildApp {
                        // Valid build mode with namespace + imageName
                        registry.set('ghcr.io')
                        namespace.set('mycompany/apps')
                        imageName.set('my-application')
                        version.set('1.2.3')
                        tags.set(['latest', 'stable'])
                        
                        context.set(file('.'))
                        buildArgs.put('VERSION', '1.2.3')
                        buildArgs.put('BUILD_ENV', 'production')
                        
                        labels.put('org.opencontainers.image.title', 'My Application')
                        labels.put('org.opencontainers.image.version', '1.2.3')
                    }
                }
            }
            
            tasks.register('verifyValidBuildConfig') {
                doLast {
                    def buildTask = tasks.getByName('dockerBuildValidBuildApp')
                    println "Valid build configuration: \${buildTask.name}"
                    println "Registry: " + buildTask.registry.get()
                    println "Namespace: " + buildTask.namespace.get()
                    println "ImageName: " + buildTask.imageName.get()
                }
            }
        """

        when:
        def result = GradleRunner.create()
            .withProjectDir(testProjectDir.toFile())
            .withPluginClasspath(System.getProperty("java.class.path").split(File.pathSeparator).collect { new File(it) })
            .withArguments('verifyValidBuildConfig', '--info')
            .build()

        then:
        result.task(':verifyValidBuildConfig').outcome == TaskOutcome.SUCCESS
        result.output.contains('Valid build configuration: dockerBuildValidBuildApp')
        result.output.contains('Registry: ghcr.io')
        result.output.contains('Namespace: mycompany/apps')
        result.output.contains('ImageName: my-application')
    }

    def "supports valid build mode configuration with repository"() {
        given:
        settingsFile << "rootProject.name = 'test-valid-build-repository'"
        
        buildFile << """
            plugins {
                id 'com.kineticfire.gradle.gradle-docker'
            }
            
            docker {
                images {
                    validRepoApp {
                        // Valid build mode with repository
                        registry.set('docker.io')
                        repository.set('mycompany/apps/my-service')
                        version.set('2.1.0')
                        tags.set(['latest', 'v2.1.0'])
                        
                        context.set(file('.'))
                        buildArgs.put('SERVICE_VERSION', '2.1.0')
                        
                        labels.put('service.name', 'my-service')
                        labels.put('service.version', '2.1.0')
                    }
                }
            }
            
            tasks.register('verifyValidRepoConfig') {
                doLast {
                    def buildTask = tasks.getByName('dockerBuildValidRepoApp')
                    println "Valid repository configuration: \${buildTask.name}"
                    println "Registry: " + buildTask.registry.get()
                    println "Repository: " + buildTask.repository.get()
                }
            }
        """

        when:
        def result = GradleRunner.create()
            .withProjectDir(testProjectDir.toFile())
            .withPluginClasspath(System.getProperty("java.class.path").split(File.pathSeparator).collect { new File(it) })
            .withArguments('verifyValidRepoConfig', '--info')
            .build()

        then:
        result.task(':verifyValidRepoConfig').outcome == TaskOutcome.SUCCESS
        result.output.contains('Valid repository configuration: dockerBuildValidRepoApp')
        result.output.contains('Registry: docker.io')
        result.output.contains('Repository: mycompany/apps/my-service')
    }

    def "supports valid sourceRef mode configuration"() {
        given:
        settingsFile << "rootProject.name = 'test-valid-sourceref'"
        
        buildFile << """
            plugins {
                id 'com.kineticfire.gradle.gradle-docker'
            }
            
            docker {
                images {
                    validSourceRefApp {
                        // Valid sourceRef mode - no build properties
                        sourceRef.set('ghcr.io/upstream/awesome-app:v1.5.0')
                        tags.set(['local:latest', 'local:stable', 'local:v1.5.0'])
                        
                        // Save configuration is allowed
                        save {
                            compression.set(com.kineticfire.gradle.docker.model.SaveCompression.GZIP)
                            outputFile.set(layout.buildDirectory.file('images/awesome-app.tar.gz'))
                            pullIfMissing.set(true)
                        }
                        
                        // Publish configuration is allowed  
                        publish {
                            to('internal') {
                                registry.set('internal.company.com')
                                repository.set('mirrors/awesome-app')
                                publishTags(['mirror-latest'])
                            }
                        }
                    }
                }
            }
            
            tasks.register('verifyValidSourceRefConfig') {
                doLast {
                    // In sourceRef mode, no build task should exist
                    def saveTask = tasks.getByName('dockerSaveValidSourceRefApp')
                    println "Save task configured: \${saveTask.name}"
                    
                    def tagTask = tasks.getByName('dockerTagValidSourceRefApp')
                    println "Tag task configured: \${tagTask.name}"
                    
                    def publishTask = tasks.getByName('dockerPublishValidSourceRefApp')
                    println "Publish task configured: \${publishTask.name}"
                    
                    println "Valid sourceRef configuration verified"
                }
            }
        """

        when:
        def result = GradleRunner.create()
            .withProjectDir(testProjectDir.toFile())
            .withPluginClasspath(System.getProperty("java.class.path").split(File.pathSeparator).collect { new File(it) })
            .withArguments('verifyValidSourceRefConfig', '--info')
            .build()

        then:
        result.task(':verifyValidSourceRefConfig').outcome == TaskOutcome.SUCCESS
        result.output.contains('Valid sourceRef configuration verified')
        result.output.contains('Save task configured: dockerSaveValidSourceRefApp')
        result.output.contains('Publish task configured: dockerPublishValidSourceRefApp')
    }

    def "supports provider-based nomenclature configuration"() {
        given:
        settingsFile << "rootProject.name = 'test-provider-nomenclature'"
        
        buildFile << """
            plugins {
                id 'com.kineticfire.gradle.gradle-docker'
            }
            
            def registryProvider = providers.gradleProperty('app.registry').orElse('docker.io')
            def namespaceProvider = providers.gradleProperty('app.namespace').orElse('defaultorg')
            def versionProvider = providers.provider { project.version.toString() }
            
            docker {
                images {
                    providerApp {
                        // Provider-based configuration for build mode
                        registry.set(registryProvider)
                        namespace.set(namespaceProvider)
                        imageName.set('provider-app')
                        version.set(versionProvider)
                        tags.set(providers.provider { 
                            ['latest', "v\${project.version}"]
                        })
                        
                        context.set(file('.'))
                        
                        buildArgs.put('VERSION', versionProvider)
                        buildArgs.put('REGISTRY', registryProvider)
                        
                        labels.put('build.version', versionProvider)
                        labels.put('build.registry', registryProvider)
                    }
                }
            }
            
            tasks.register('verifyProviderNomenclature') {
                doLast {
                    def buildTask = tasks.getByName('dockerBuildProviderApp')
                    println "Provider nomenclature configuration: \${buildTask.name}"
                    
                    // Values should be resolved during execution
                    println "Registry: " + buildTask.registry.get()
                    println "Namespace: " + buildTask.namespace.get()
                    println "Version: " + buildTask.version.get()
                    println "Tags: " + buildTask.tags.get()
                }
            }
        """

        when:
        def result = GradleRunner.create()
            .withProjectDir(testProjectDir.toFile())
            .withPluginClasspath(System.getProperty("java.class.path").split(File.pathSeparator).collect { new File(it) })
            .withArguments('verifyProviderNomenclature', '--info')
            .build()

        then:
        result.task(':verifyProviderNomenclature').outcome == TaskOutcome.SUCCESS
        result.output.contains('Provider nomenclature configuration: dockerBuildProviderApp')
        result.output.contains('Registry: docker.io')
        result.output.contains('Namespace: defaultorg')
        result.output.contains('Tags: [latest,')
    }
}