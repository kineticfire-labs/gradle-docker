/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.kineticfire.gradle.docker

import com.kineticfire.gradle.docker.model.SaveCompression
import org.gradle.testkit.runner.GradleRunner
import org.gradle.testkit.runner.TaskOutcome
import spock.lang.Specification
import spock.lang.Ignore
import spock.lang.TempDir

import java.nio.file.Path

/**
 * Functional tests for Provider API edge cases and advanced configuration cache scenarios
 *
 * NOTE: These tests focus on configuration verification rather than actual Docker execution
 * due to TestKit limitations with Gradle 9. Real Docker operations are covered by
 * integration tests in the plugin-integration-test project.
 */
class DockerProviderAPIFunctionalTest extends Specification {

    @TempDir
    Path testProjectDir

    File settingsFile
    File buildFile

    def setup() {
        settingsFile = testProjectDir.resolve('settings.gradle').toFile()
        buildFile = testProjectDir.resolve('build.gradle').toFile()
    }

    def "docker Provider API supports complex gradle property resolution chains"() {
        given:
        settingsFile << "rootProject.name = 'test-provider-chains'"

        buildFile << """
            import com.kineticfire.gradle.docker.model.SaveCompression

            plugins {
                id 'com.kineticfire.gradle.gradle-docker'
            }

            // Complex provider chains with multiple fallbacks
            def registryProvider = providers.gradleProperty('docker.registry')
                .orElse(providers.systemProperty('DOCKER_REGISTRY'))
                .orElse(providers.environmentVariable('DOCKER_REGISTRY'))
                .orElse('docker.io')

            def namespaceProvider = providers.gradleProperty('docker.namespace')
                .orElse(providers.provider {
                    // Dynamic fallback based on project structure
                    def group = project.group?.toString()
                    return group ? group.replace('.', '/') : 'default'
                })

            def versionProvider = providers.gradleProperty('release.version')
                .orElse(providers.provider {
                    def baseVersion = project.version.toString()
                    def buildId = System.getenv('BUILD_ID')
                    return buildId ? "\${baseVersion}-build.\${buildId}" : "\${baseVersion}-SNAPSHOT"
                })

            def tagsProvider = providers.provider {
                def version = versionProvider.get()
                def tags = ['latest']

                // Add version-based tags
                if (!version.contains('SNAPSHOT')) {
                    tags.add("v\${version}")

                    // Add semantic version tags
                    def versionParts = version.split('\\\\.')
                    if (versionParts.length >= 2) {
                        tags.add("v\${versionParts[0]}.\${versionParts[1]}")
                    }
                    if (versionParts.length >= 1) {
                        tags.add("v\${versionParts[0]}")
                    }
                } else {
                    tags.add('snapshot')
                    tags.add("snapshot-\${new Date().format('yyyyMMdd')}")
                }

                return tags
            }

            docker {
                images {
                    providerChainApp {
                        registry.set(registryProvider)
                        namespace.set(namespaceProvider)
                        imageName.set('provider-chain-test')
                        version.set(versionProvider)
                        tags.set(tagsProvider)
                        context.set(file('.'))

                        // Provider-based build args
                        buildArgs.put('REGISTRY', registryProvider)
                        buildArgs.put('VERSION', versionProvider)
                        buildArgs.put('BUILD_ENV', providers.gradleProperty('build.env').orElse('development'))

                        // Provider-based labels
                        labels.put('registry.source', registryProvider)
                        labels.put('version.resolved', versionProvider)
                        labels.put('namespace.computed', namespaceProvider)
                        labels.put('build.timestamp', providers.provider { new Date().toString() })
                    }
                }
            }

            tasks.register('verifyProviderChains') {
                doLast {
                    def buildTask = tasks.getByName('dockerBuildProviderChainApp')

                    println "=== Provider Chain Resolution Verification ==="

                    // Verify all providers are resolved
                    println "Registry: " + buildTask.registry.get()
                    println "Namespace: " + buildTask.namespace.get()
                    println "Version: " + buildTask.version.get()
                    println "Tags: " + buildTask.tags.get()

                    // Verify fallback resolution worked
                    assert buildTask.registry.get() == 'docker.io' // Should use default fallback
                    assert buildTask.namespace.get() != null
                    assert buildTask.version.get().contains('SNAPSHOT') // Should use project version fallback

                    // Verify labels resolved
                    def labels = buildTask.labels.get()
                    assert labels['registry.source'] == 'docker.io'
                    assert labels.containsKey('version.resolved')
                    assert labels.containsKey('build.timestamp')

                    println "Provider chain resolution verification completed"
                }
            }
        """

        when:
        def result = GradleRunner.create()
            .withProjectDir(testProjectDir.toFile())
            .withPluginClasspath(System.getProperty("java.class.path").split(File.pathSeparator).collect { new File(it) })
            .withArguments('verifyProviderChains', '--info')
            .build()

        then:
        result.task(':verifyProviderChains').outcome == TaskOutcome.SUCCESS
        result.output.contains('=== Provider Chain Resolution Verification ===')
        result.output.contains('Registry: docker.io')
        result.output.contains('Provider chain resolution verification completed')
    }

    @Ignore("Temporarily disabled due to complex Provider API issues")
    def "docker Provider API supports late-bound property resolution with interdependencies"() {
        given:
        settingsFile << "rootProject.name = 'test-late-bound-providers'"

        buildFile << """
            import com.kineticfire.gradle.docker.model.SaveCompression

            plugins {
                id 'com.kineticfire.gradle.gradle-docker'
            }

            // Late-bound providers with interdependencies
            def baseImageProvider = providers.gradleProperty('base.image').orElse('ubuntu:20.04')

            def deploymentModeProvider = providers.gradleProperty('deployment.mode').orElse('development')

            def registryProvider = providers.provider {
                def mode = deploymentModeProvider.get()
                switch (mode) {
                    case 'production':
                        return 'prod.company.com:5000'
                    case 'staging':
                        return 'staging.company.com'
                    case 'development':
                    default:
                        return 'dev.company.com'
                }
            }

            def namespaceProvider = providers.provider {
                def mode = deploymentModeProvider.get()
                def projectName = project.name
                return "${baseVersion}-${safeBranch}-build.${buildNumber}").split(File.pathSeparator).collect { new File(it) })
            .withArguments('verifyProviderComposition', '--info')
            .build()

        then:
        result.task(':verifyProviderComposition').outcome == TaskOutcome.SUCCESS
        result.output.contains('=== Provider Composition Verification ===')
        result.output.contains('Registry: base.registry.com')
        result.output.contains('Namespace: development/base/apps')
        result.output.contains('Provider composition verification completed')
    }
}