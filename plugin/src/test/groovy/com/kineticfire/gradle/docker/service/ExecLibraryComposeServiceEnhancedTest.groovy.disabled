/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.kineticfire.gradle.docker.service

import com.kineticfire.gradle.docker.exception.ComposeServiceException
import com.kineticfire.gradle.docker.model.*
import org.gradle.api.logging.Logger
import org.gradle.api.services.BuildServiceParameters
import spock.lang.Specification
import spock.lang.TempDir

import java.nio.file.Files
import java.nio.file.Path
import java.time.Duration
import java.util.concurrent.CompletableFuture
import java.util.concurrent.ExecutionException

/**
 * Enhanced unit tests for ExecLibraryComposeService to achieve 100% coverage
 * Uses comprehensive process mocking to test all Docker Compose operations
 */
class ExecLibraryComposeServiceEnhancedTest extends Specification {

    @TempDir
    Path tempDir

    TestableExecLibraryComposeService service

    def setup() {
        service = new TestableExecLibraryComposeService()
    }

    // Constructor and initialization tests

    def "constructor initializes successfully with available Docker Compose"() {
        given:
        def service = new TestableExecLibraryComposeService(true)

        expect:
        service != null
    }

    def "constructor throws exception when Docker Compose not available"() {
        when:
        new TestableExecLibraryComposeService(false)

        then:
        def ex = thrown(ComposeServiceException)
        ex.errorType == ComposeServiceException.ErrorType.COMPOSE_UNAVAILABLE
        ex.message.contains("Docker Compose is not available")
    }

    def "validateDockerCompose detects modern docker compose command"() {
        given:
        service.setProcessResult(0, "", "")

        when:
        service.testValidateDockerCompose()

        then:
        noExceptionThrown()
    }

    def "validateDockerCompose falls back to legacy docker-compose"() {
        given:
        service.setProcessResults([
            [1, "", ""],  // docker compose version fails
            [0, "", ""]   // docker-compose --version succeeds
        ])

        when:
        service.testValidateDockerCompose()

        then:
        noExceptionThrown()
    }

    def "validateDockerCompose throws exception when neither command available"() {
        given:
        service.setProcessResults([
            [1, "", ""],  // docker compose version fails
            [1, "", ""]   // docker-compose --version fails
        ])

        when:
        service.testValidateDockerCompose()

        then:
        def ex = thrown(ComposeServiceException)
        ex.errorType == ComposeServiceException.ErrorType.COMPOSE_UNAVAILABLE
    }

    def "getComposeCommand returns modern docker compose"() {
        given:
        service.setProcessResult(0, "", "")

        when:
        def command = service.testGetComposeCommand()

        then:
        command == ["docker", "compose"]
    }

    def "getComposeCommand returns legacy docker-compose"() {
        given:
        service.setProcessResult(1, "", "")

        when:
        def command = service.testGetComposeCommand()

        then:
        command == ["docker-compose"]
    }

    // upStack method tests

    def "upStack executes compose up successfully"() {
        given:
        def composeFile = createComposeFile("docker-compose.yml", "services:\n  web:\n    image: nginx")
        def config = new ComposeConfig([composeFile], "test-project", "test-stack")

        service.setProcessResults([
            [0, "", ""],  // compose up
            [0, '{"Service":"web","State":"running","Image":"nginx","ID":"abc123"}', ""]  // compose ps
        ])

        when:
        def result = service.upStack(config).get()

        then:
        result.stackName == "test-stack"
        result.projectName == "test-project"
        result.services.containsKey("web")
        result.services["web"].state == ServiceStatus.RUNNING
    }

    def "upStack handles multiple compose files"() {
        given:
        def file1 = createComposeFile("base.yml", "services:\n  web:\n    image: nginx")
        def file2 = createComposeFile("override.yml", "services:\n  web:\n    ports:\n      - 80:80")
        def config = new ComposeConfig([file1, file2], "multi-project", "multi-stack")

        service.setProcessResults([
            [0, "", ""],  // compose up
            [0, "", ""]   // compose ps
        ])

        when:
        def result = service.upStack(config).get()

        then:
        result.projectName == "multi-project"
        result.stackName == "multi-stack"
    }

    def "upStack handles env files"() {
        given:
        def composeFile = createComposeFile("docker-compose.yml", "services:\n  web:\n    image: nginx")
        def envFile = createEnvFile(".env", "NGINX_TAG=latest")
        def config = new ComposeConfig([composeFile], [envFile], "env-project", "env-stack", [:])

        service.setProcessResults([
            [0, "", ""],  // compose up
            [0, "", ""]   // compose ps
        ])

        when:
        def result = service.upStack(config).get()

        then:
        result.projectName == "env-project"
    }

    def "upStack handles compose up failure"() {
        given:
        def composeFile = createComposeFile("docker-compose.yml", "services:\n  web:\n    image: nginx")
        def config = new ComposeConfig([composeFile], "failed-project", "failed-stack")

        service.setProcessResult(1, "", "Compose up failed")

        when:
        service.upStack(config).get()

        then:
        def ex = thrown(ExecutionException)
        ex.cause instanceof ComposeServiceException
        ex.cause.errorType == ComposeServiceException.ErrorType.SERVICE_START_FAILED
        ex.cause.message.contains("Docker Compose up failed with exit code 1")
    }

    def "upStack handles general exception"() {
        given:
        def composeFile = createComposeFile("docker-compose.yml", "services:\n  web:\n    image: nginx")
        def config = new ComposeConfig([composeFile], "error-project", "error-stack")

        service.setProcessException(new IOException("Process creation failed"))

        when:
        service.upStack(config).get()

        then:
        def ex = thrown(ExecutionException)
        ex.cause instanceof ComposeServiceException
        ex.cause.errorType == ComposeServiceException.ErrorType.SERVICE_START_FAILED
        ex.cause.message.contains("Failed to start compose stack")
    }

    def "upStack validates null config"() {
        when:
        service.upStack(null)

        then:
        thrown(NullPointerException)
    }

    // downStack method tests

    def "downStack with project name executes successfully"() {
        given:
        service.setProcessResult(0, "", "")

        when:
        service.downStack("test-project").get()

        then:
        noExceptionThrown()
    }

    def "downStack with project name handles failure"() {
        given:
        service.setProcessResult(1, "", "Compose down failed")

        when:
        service.downStack("test-project").get()

        then:
        def ex = thrown(ExecutionException)
        ex.cause instanceof ComposeServiceException
        ex.cause.errorType == ComposeServiceException.ErrorType.SERVICE_STOP_FAILED
    }

    def "downStack with project name validates null parameter"() {
        when:
        service.downStack((String) null)

        then:
        thrown(NullPointerException)
    }

    def "downStack with config executes successfully"() {
        given:
        def composeFile = createComposeFile("docker-compose.yml", "services:\n  web:\n    image: nginx")
        def config = new ComposeConfig([composeFile], "test-project", "test-stack")

        service.setProcessResult(0, "", "")

        when:
        service.downStack(config).get()

        then:
        noExceptionThrown()
    }

    def "downStack with config handles multiple files and env files"() {
        given:
        def file1 = createComposeFile("base.yml", "services:\n  web:\n    image: nginx")
        def file2 = createComposeFile("override.yml", "services:\n  web:\n    ports:\n      - 80:80")
        def envFile = createEnvFile(".env", "NGINX_TAG=latest")
        def config = new ComposeConfig([file1, file2], [envFile], "multi-project", "multi-stack", [:])

        service.setProcessResult(0, "", "")

        when:
        service.downStack(config).get()

        then:
        noExceptionThrown()
    }

    def "downStack with config handles failure"() {
        given:
        def composeFile = createComposeFile("docker-compose.yml", "services:\n  web:\n    image: nginx")
        def config = new ComposeConfig([composeFile], "test-project", "test-stack")

        service.setProcessResult(1, "", "Compose down failed")

        when:
        service.downStack(config).get()

        then:
        def ex = thrown(ExecutionException)
        ex.cause instanceof ComposeServiceException
        ex.cause.errorType == ComposeServiceException.ErrorType.SERVICE_STOP_FAILED
    }

    def "downStack with config validates null parameter"() {
        when:
        service.downStack((ComposeConfig) null)

        then:
        thrown(NullPointerException)
    }

    // waitForServices method tests

    def "waitForServices completes when all services ready"() {
        given:
        def config = new WaitConfig("test-project", ["web", "db"], Duration.ofSeconds(30), ServiceStatus.RUNNING)

        service.setProcessResults([
            [0, "web    running", ""],  // first check
            [0, "db     running", ""]   // second check
        ])

        when:
        def result = service.waitForServices(config).get()

        then:
        result == ServiceStatus.RUNNING
    }

    def "waitForServices times out when services not ready"() {
        given:
        def config = new WaitConfig("test-project", ["web"], Duration.ofMillis(100), ServiceStatus.RUNNING, Duration.ofMillis(50))

        service.setProcessResult(0, "web    starting", "")

        when:
        service.waitForServices(config).get()

        then:
        def ex = thrown(ExecutionException)
        ex.cause instanceof ComposeServiceException
        ex.cause.errorType == ComposeServiceException.ErrorType.SERVICE_TIMEOUT
        ex.cause.message.contains("Timeout waiting for services")
    }

    def "waitForServices handles process execution error"() {
        given:
        def config = new WaitConfig("test-project", ["web"], Duration.ofSeconds(30), ServiceStatus.RUNNING)

        service.setProcessException(new IOException("Process failed"))

        when:
        service.waitForServices(config).get()

        then:
        def ex = thrown(ExecutionException)
        ex.cause instanceof ComposeServiceException
        ex.cause.errorType == ComposeServiceException.ErrorType.SERVICE_TIMEOUT
        ex.cause.message.contains("Error waiting for services")
    }

    def "waitForServices validates null config"() {
        when:
        service.waitForServices(null)

        then:
        thrown(NullPointerException)
    }

    // captureLogs method tests

    def "captureLogs captures output successfully"() {
        given:
        def config = new LogsConfig(["web", "db"])

        service.setProcessResult(0, "web logs\ndb logs", "")

        when:
        def result = service.captureLogs("test-project", config).get()

        then:
        result == "web logs\ndb logs"
    }

    def "captureLogs handles follow option"() {
        given:
        def config = new LogsConfig(["web"])
        config.follow = true

        service.setProcessResult(0, "streaming logs", "")

        when:
        def result = service.captureLogs("test-project", config).get()

        then:
        result == "streaming logs"
    }

    def "captureLogs handles tail option"() {
        given:
        def config = new LogsConfig(["web"])
        config.tail = 100

        service.setProcessResult(0, "last 100 lines", "")

        when:
        def result = service.captureLogs("test-project", config).get()

        then:
        result == "last 100 lines"
    }

    def "captureLogs handles empty services list"() {
        given:
        def config = new LogsConfig([])

        service.setProcessResult(0, "all services logs", "")

        when:
        def result = service.captureLogs("test-project", config).get()

        then:
        result == "all services logs"
    }

    def "captureLogs handles process failure"() {
        given:
        def config = new LogsConfig(["web"])

        service.setProcessResult(1, "", "Log capture failed")

        when:
        service.captureLogs("test-project", config).get()

        then:
        def ex = thrown(ExecutionException)
        ex.cause instanceof ComposeServiceException
        ex.cause.errorType == ComposeServiceException.ErrorType.LOGS_CAPTURE_FAILED
    }

    def "captureLogs validates null project name"() {
        when:
        service.captureLogs(null, new LogsConfig([]))

        then:
        thrown(NullPointerException)
    }

    def "captureLogs validates null config"() {
        when:
        service.captureLogs("test-project", null)

        then:
        thrown(NullPointerException)
    }

    // getStackServices method tests

    def "getStackServices parses JSON output correctly"() {
        given:
        def jsonOutput = '''{"Service":"web","State":"running","Image":"nginx","ID":"abc123","Names":"test_web_1"}
{"Service":"db","State":"exited","Image":"postgres","ID":"def456","Names":"test_db_1"}'''

        service.setProcessResult(0, jsonOutput, "")

        when:
        def services = service.testGetStackServices("test-project")

        then:
        services.size() == 2
        services["web"].state == ServiceStatus.RUNNING
        services["web"].image == "nginx"
        services["db"].state == ServiceStatus.STOPPED
        services["db"].image == "postgres"
    }

    def "getStackServices handles empty output"() {
        given:
        service.setProcessResult(0, "", "")

        when:
        def services = service.testGetStackServices("test-project")

        then:
        services.isEmpty()
    }

    def "getStackServices handles process failure"() {
        given:
        service.setProcessResult(1, "", "Command failed")

        when:
        def services = service.testGetStackServices("test-project")

        then:
        services.isEmpty()
    }

    def "getStackServices handles malformed JSON"() {
        given:
        service.setProcessResult(0, "invalid json line", "")

        when:
        def services = service.testGetStackServices("test-project")

        then:
        services.isEmpty()
    }

    // parseServiceState method tests

    def "parseServiceState correctly identifies running states"() {
        expect:
        service.testParseServiceState(status) == ServiceStatus.RUNNING

        where:
        status << [
            "Up 5 minutes",
            "running",
            "RUNNING",
            "Up (healthy)",
            "running (healthy)"
        ]
    }

    def "parseServiceState correctly identifies healthy states"() {
        expect:
        service.testParseServiceState(status) == ServiceStatus.HEALTHY

        where:
        status << [
            "Up (healthy)",
            "running (healthy)",
            "RUNNING (HEALTHY)",
            "healthy"
        ]
    }

    def "parseServiceState correctly identifies stopped states"() {
        expect:
        service.testParseServiceState(status) == ServiceStatus.STOPPED

        where:
        status << [
            "Exit 0",
            "Exited (0)",
            "stopped",
            "STOPPED",
            "exit code 1"
        ]
    }

    def "parseServiceState correctly identifies restarting states"() {
        expect:
        service.testParseServiceState(status) == ServiceStatus.RESTARTING

        where:
        status << [
            "Restarting",
            "restarting (1)",
            "RESTARTING",
            "restart policy"
        ]
    }

    def "parseServiceState handles unknown states"() {
        expect:
        service.testParseServiceState(status) == ServiceStatus.UNKNOWN

        where:
        status << [
            null,
            "",
            "   ",
            "unknown state",
            "pending",
            "creating"
        ]
    }

    // checkServiceReady method tests

    def "checkServiceReady detects running service for RUNNING target"() {
        given:
        service.setProcessResult(0, "web    Up 5 minutes", "")

        when:
        def result = service.testCheckServiceReady("test-project", "web", ServiceStatus.RUNNING)

        then:
        result == true
    }

    def "checkServiceReady detects healthy service for HEALTHY target"() {
        given:
        service.setProcessResult(0, "web    Up (healthy)", "")

        when:
        def result = service.testCheckServiceReady("test-project", "web", ServiceStatus.HEALTHY)

        then:
        result == true
    }

    def "checkServiceReady detects not ready service"() {
        given:
        service.setProcessResult(0, "web    starting", "")

        when:
        def result = service.testCheckServiceReady("test-project", "web", ServiceStatus.RUNNING)

        then:
        result == false
    }

    def "checkServiceReady handles process failure"() {
        given:
        service.setProcessResult(1, "", "Command failed")

        when:
        def result = service.testCheckServiceReady("test-project", "web", ServiceStatus.RUNNING)

        then:
        result == false
    }

    def "checkServiceReady handles exception"() {
        given:
        service.setProcessException(new IOException("Process failed"))

        when:
        def result = service.testCheckServiceReady("test-project", "web", ServiceStatus.RUNNING)

        then:
        result == false
    }

    // Helper methods

    private Path createComposeFile(String filename, String content) {
        def file = tempDir.resolve(filename)
        Files.writeString(file, content)
        return file
    }

    private Path createEnvFile(String filename, String content) {
        def file = tempDir.resolve(filename)
        Files.writeString(file, content)
        return file
    }

    /**
     * Testable implementation of ExecLibraryComposeService for testing
     */
    static class TestableExecLibraryComposeService extends ExecLibraryComposeService {

        Logger logger
        List<Map> processResults = []
        int processResultIndex = 0
        Exception processException

        TestableExecLibraryComposeService(boolean composeAvailable = true) {
            if (!composeAvailable) {
                throw new ComposeServiceException(
                    ComposeServiceException.ErrorType.COMPOSE_UNAVAILABLE,
                    "Docker Compose is not available. Please install Docker Compose.",
                    "Install Docker Compose or Docker Desktop which includes Compose"
                )
            }
        }

        @Override
        BuildServiceParameters.None getParameters() {
            return null
        }

        @Override
        protected void validateDockerCompose() {
            // Override to use mocked process results
            testValidateDockerCompose()
        }

        void testValidateDockerCompose() {
            try {
                def result1 = executeProcess(["docker", "compose", "version"])
                if (result1.exitCode != 0) {
                    def result2 = executeProcess(["docker-compose", "--version"])
                    if (result2.exitCode != 0) {
                        throw new ComposeServiceException(
                            ComposeServiceException.ErrorType.COMPOSE_UNAVAILABLE,
                            "Docker Compose is not available. Please install Docker Compose.",
                            "Install Docker Compose or Docker Desktop which includes Compose"
                        )
                    }
                }
            } catch (Exception e) {
                if (e instanceof ComposeServiceException) {
                    throw e
                }
                throw new ComposeServiceException(
                    ComposeServiceException.ErrorType.COMPOSE_UNAVAILABLE,
                    "Failed to validate Docker Compose installation: ${e.message}",
                    "Ensure Docker and Docker Compose are installed and accessible in PATH"
                )
            }
        }

        @Override
        protected List<String> getComposeCommand() {
            return testGetComposeCommand()
        }

        List<String> testGetComposeCommand() {
            try {
                def result = executeProcess(["docker", "compose", "version"])
                if (result.exitCode == 0) {
                    return ["docker", "compose"]
                }
            } catch (Exception ignored) {
                // Fall through to legacy command
            }
            return ["docker-compose"]
        }

        @Override
        protected Map<String, ServiceInfo> getStackServices(String projectName) {
            return testGetStackServices(projectName)
        }

        Map<String, ServiceInfo> testGetStackServices(String projectName) {
            try {
                def result = executeProcess(["compose", "-p", projectName, "ps", "--format", "json"])

                if (result.exitCode != 0) {
                    return [:]
                }

                def services = [:]
                if (result.output?.trim()) {
                    result.output.split('\n').each { line ->
                        if (line?.trim()) {
                            try {
                                def json = new groovy.json.JsonSlurper().parseText(line)
                                def serviceName = json.Service ?: json.Name?.split('_')?.getAt(1)
                                def status = json.State ?: json.Status
                                def ports = json.Ports ? [json.Ports] : []

                                if (serviceName) {
                                    def serviceState = parseServiceState(status)
                                    services[serviceName] = new ServiceInfo(
                                        serviceName,
                                        json.Image ?: 'unknown',
                                        serviceState,
                                        ports,
                                        json.Names ? [json.Names] : [json.Name ?: serviceName],
                                        json.ID ?: 'unknown'
                                    )
                                }
                            } catch (Exception e) {
                                // Ignore malformed lines
                            }
                        }
                    }
                }

                return services

            } catch (Exception e) {
                return [:]
            }
        }

        ServiceStatus testParseServiceState(String status) {
            return parseServiceState(status)
        }

        @Override
        protected boolean checkServiceReady(String projectName, String serviceName, ServiceStatus targetState) {
            return testCheckServiceReady(projectName, serviceName, targetState)
        }

        boolean testCheckServiceReady(String projectName, String serviceName, ServiceStatus targetState) {
            try {
                def result = executeProcess(["compose", "-p", projectName, "ps", serviceName, "--format", "table"])

                if (result.exitCode == 0 && result.output) {
                    if (targetState == ServiceStatus.RUNNING) {
                        return result.output.toLowerCase().contains("up") || result.output.toLowerCase().contains("running")
                    } else if (targetState == ServiceStatus.HEALTHY) {
                        return result.output.toLowerCase().contains("healthy")
                    }
                }

                return false

            } catch (Exception e) {
                return false
            }
        }

        void setProcessResult(int exitCode, String output, String error) {
            processResults = [[exitCode: exitCode, output: output, error: error]]
            processResultIndex = 0
        }

        void setProcessResults(List<List> results) {
            processResults = results.collect { [exitCode: it[0], output: it[1], error: it[2]] }
            processResultIndex = 0
        }

        void setProcessException(Exception exception) {
            this.processException = exception
        }

        private Map executeProcess(List<String> command) {
            if (processException) {
                throw processException
            }

            if (processResultIndex < processResults.size()) {
                def result = processResults[processResultIndex++]
                return [exitCode: result.exitCode, output: result.output, error: result.error]
            }

            return [exitCode: 0, output: "", error: ""]
        }
    }
}