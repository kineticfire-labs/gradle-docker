/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.kineticfire.gradle.docker.junit

import com.kineticfire.gradle.docker.junit.service.FileService
import com.kineticfire.gradle.docker.junit.service.ProcessExecutor
import com.kineticfire.gradle.docker.junit.service.SystemPropertyService
import com.kineticfire.gradle.docker.junit.service.TimeService
import org.junit.jupiter.api.extension.ExtensionContext
import spock.lang.Specification
import spock.lang.Subject

import java.lang.reflect.InvocationTargetException
import java.lang.reflect.Method
import java.nio.file.Path
import java.nio.file.Paths
import java.time.LocalDateTime
import java.util.concurrent.TimeUnit
import java.util.stream.Stream

/**
 * Unit tests for DockerComposeMethodExtension focused on achieving 100% coverage.
 */
class DockerComposeMethodExtensionTest extends Specification {

    ProcessExecutor processExecutor = Mock()
    FileService fileService = Mock()
    SystemPropertyService systemPropertyService = Mock()
    TimeService timeService = Mock()
    ExtensionContext context = Mock()

    @Subject
    DockerComposeMethodExtension extension

    def setup() {
        extension = new DockerComposeMethodExtension(processExecutor, fileService, systemPropertyService, timeService)
    }

    def "constructor with default services creates successfully"() {
        when:
        def defaultExtension = new DockerComposeMethodExtension()

        then:
        defaultExtension != null
    }

    def "constructor with services creates successfully"() {
        expect:
        extension != null
    }

    def "sanitizeProjectName handles various inputs"() {
        expect:
        invokeSanitizeProjectName("validproject") == "validproject"
        invokeSanitizeProjectName("test@project#name") == "test-project-name"
        invokeSanitizeProjectName("test---project") == "test-project"
        invokeSanitizeProjectName("---project") == "project"
        invokeSanitizeProjectName("project---") == "project"
        invokeSanitizeProjectName("-project") == "project"
        invokeSanitizeProjectName("") == "test-project"
    }

    def "capitalize handles various inputs"() {
        expect:
        invokeCapitalize("hello") == "Hello"
        invokeCapitalize("") == ""
        invokeCapitalize(null) == null
        invokeCapitalize("a") == "A"
    }

    def "getStackName with valid property returns stack name"() {
        given:
        systemPropertyService.getProperty("docker.compose.stack") >> "test-stack"

        when:
        String result = invokeGetStackName(context)

        then:
        result == "test-stack"
    }

    def "getStackName with null property throws exception"() {
        given:
        systemPropertyService.getProperty("docker.compose.stack") >> null

        when:
        invokeGetStackName(context)

        then:
        def ex = thrown(java.lang.reflect.InvocationTargetException)
        ex.cause instanceof IllegalStateException
    }

    def "getStackName with empty property throws exception"() {
        given:
        systemPropertyService.getProperty("docker.compose.stack") >> ""

        when:
        invokeGetStackName(context)

        then:
        def ex = thrown(java.lang.reflect.InvocationTargetException)
        ex.cause instanceof IllegalStateException
    }

    def "getProjectName handles various scenarios"() {
        given:
        systemPropertyService.getProperty("docker.compose.project") >> projectProperty
        context.getTestClass() >> testClass

        expect:
        invokeGetProjectName(context) == expectedResult

        where:
        projectProperty | testClass                     | expectedResult
        "test-project"  | Optional.of(String.class)    | "test-project"
        null            | Optional.of(String.class)    | "String"
        ""              | Optional.of(String.class)    | "String"
        null            | Optional.empty()             | "test"
    }

    def "generateUniqueProjectName generates correct format"() {
        given:
        systemPropertyService.getProperty("docker.compose.project") >> "base"
        context.getTestClass() >> Optional.of(String.class)
        context.getTestMethod() >> Optional.of(String.class.getMethod("toString"))
        timeService.now() >> LocalDateTime.of(2023, 1, 1, 12, 30, 45)

        when:
        String result = invokeGenerateUniqueProjectName(context)

        then:
        result == "base-string-tostring-123045"
    }

    def "generateUniqueProjectName with no class uses unknown"() {
        given:
        systemPropertyService.getProperty("docker.compose.project") >> "base"
        context.getTestClass() >> Optional.empty()
        context.getTestMethod() >> Optional.empty()
        timeService.now() >> LocalDateTime.of(2023, 1, 1, 12, 30, 45)

        when:
        String result = invokeGenerateUniqueProjectName(context)

        then:
        result == "base-unknown-unknown-123045"
    }

    def "beforeEach executes basic workflow"() {
        given:
        systemPropertyService.getProperty("docker.compose.stack") >> "test-stack"
        systemPropertyService.getProperty("docker.compose.project") >> "test-project"
        context.getTestClass() >> Optional.of(String.class)
        context.getTestMethod() >> Optional.of(String.class.getDeclaredMethods()[0])
        timeService.now() >> LocalDateTime.of(2023, 1, 1, 12, 30, 45)

        Path composeFile = Paths.get("src/integrationTest/resources/compose/integration-method.yml")
        fileService.resolve("src/integrationTest/resources/compose/integration-method.yml") >> composeFile
        fileService.exists(composeFile) >> true
        fileService.resolve(".") >> Paths.get(".")
        fileService.toFile(_) >> new File(".")
        fileService.resolve("build") >> Paths.get("build")
        fileService.exists(Paths.get("build/compose-state")) >> true
        fileService.list(Paths.get("build/compose-state")) >> Stream.empty()

        processExecutor.executeWithTimeout(_, _, _) >> new ProcessExecutor.ProcessResult(0, "Success")
        processExecutor.executeInDirectory(_, _) >> new ProcessExecutor.ProcessResult(0, "Success")
        processExecutor.execute("docker", "compose", "-p", _, "ps", "--format", "json") >>
            new ProcessExecutor.ProcessResult(0, '{"Health":"healthy"}')

        when:
        extension.beforeEach(context)

        then:
        noExceptionThrown()
    }

    def "afterEach executes basic cleanup"() {
        given:
        // Set up the project name first
        systemPropertyService.getProperty("docker.compose.stack") >> "test-stack"
        systemPropertyService.getProperty("docker.compose.project") >> "test-project"
        context.getTestClass() >> Optional.of(String.class)
        context.getTestMethod() >> Optional.of(String.class.getDeclaredMethods()[0])
        timeService.now() >> LocalDateTime.of(2023, 1, 1, 12, 30, 45)

        Path composeFile = Paths.get("src/integrationTest/resources/compose/integration-method.yml")
        fileService.resolve("src/integrationTest/resources/compose/integration-method.yml") >> composeFile
        fileService.exists(composeFile) >> true
        fileService.resolve(".") >> Paths.get(".")
        fileService.toFile(_) >> new File(".")
        fileService.resolve("build") >> Paths.get("build")
        fileService.exists(Paths.get("build/compose-state")) >> true
        fileService.list(Paths.get("build/compose-state")) >> Stream.empty()

        processExecutor.executeWithTimeout(_, _, _) >> new ProcessExecutor.ProcessResult(0, "Success")
        processExecutor.executeInDirectory(_, _) >> new ProcessExecutor.ProcessResult(0, "Success")
        processExecutor.execute("docker", "compose", "-p", _, "ps", "--format", "json") >>
            new ProcessExecutor.ProcessResult(0, '{"Health":"healthy"}')
        processExecutor.execute("docker", "ps", "-aq", "--filter", _) >> new ProcessExecutor.ProcessResult(0, "")

        extension.beforeEach(context)  // Initialize state

        when:
        extension.afterEach(context)

        then:
        noExceptionThrown()
    }

    def "waitForStackToBeReady returns early with healthy container"() {
        given:
        processExecutor.execute("docker", "compose", "-p", "test-project", "ps", "--format", "json") >>
            new ProcessExecutor.ProcessResult(0, '{"Health":"healthy"}')

        when:
        invokeWaitForStackToBeReady("test-stack", "test-project")

        then:
        noExceptionThrown()
    }

    def "waitForStackToBeReady returns early with running container"() {
        given:
        processExecutor.execute("docker", "compose", "-p", "test-project", "ps", "--format", "json") >>
            new ProcessExecutor.ProcessResult(0, '{"State":"running"}')

        when:
        invokeWaitForStackToBeReady("test-stack", "test-project")

        then:
        noExceptionThrown()
    }

    def "waitForStackToBeReady retries with unhealthy container"() {
        given:
        processExecutor.execute("docker", "compose", "-p", "test-project", "ps", "--format", "json") >>> [
            new ProcessExecutor.ProcessResult(0, '{"State":"starting"}'),
            new ProcessExecutor.ProcessResult(0, '{"Health":"healthy"}')
        ]

        when:
        invokeWaitForStackToBeReady("test-stack", "test-project")

        then:
        noExceptionThrown()
    }

    def "waitForStackToBeReady handles process failure"() {
        given:
        processExecutor.execute("docker", "compose", "-p", "test-project", "ps", "--format", "json") >>> [
            { throw new IOException("Process failed") },
            new ProcessExecutor.ProcessResult(0, '{"Health":"healthy"}')
        ]

        when:
        invokeWaitForStackToBeReady("test-stack", "test-project")

        then:
        noExceptionThrown()
    }

    // Helper methods for testing private methods via reflection

    private String invokeSanitizeProjectName(String projectName) {
        Method method = DockerComposeMethodExtension.class.getDeclaredMethod("sanitizeProjectName", String.class)
        method.setAccessible(true)
        return (String) method.invoke(extension, projectName)
    }

    private String invokeCapitalize(String str) {
        try {
            Method method = DockerComposeMethodExtension.class.getDeclaredMethod("capitalize", String.class)
            method.setAccessible(true)
            return (String) method.invoke(extension, (Object) str)
        } catch (InvocationTargetException e) {
            if (e.cause instanceof RuntimeException) {
                throw (RuntimeException) e.cause
            }
            throw new RuntimeException(e.cause)
        }
    }

    private String invokeGetStackName(ExtensionContext context) {
        Method method = DockerComposeMethodExtension.class.getDeclaredMethod("getStackName", ExtensionContext.class)
        method.setAccessible(true)
        return (String) method.invoke(extension, context)
    }

    private String invokeGetProjectName(ExtensionContext context) {
        Method method = DockerComposeMethodExtension.class.getDeclaredMethod("getProjectName", ExtensionContext.class)
        method.setAccessible(true)
        return (String) method.invoke(extension, context)
    }

    private String invokeGenerateUniqueProjectName(ExtensionContext context) {
        Method method = DockerComposeMethodExtension.class.getDeclaredMethod("generateUniqueProjectName", ExtensionContext.class)
        method.setAccessible(true)
        return (String) method.invoke(extension, context)
    }

    private void invokeWaitForStackToBeReady(String stackName, String uniqueProjectName) {
        Method method = DockerComposeMethodExtension.class.getDeclaredMethod("waitForStackToBeReady", String.class, String.class)
        method.setAccessible(true)
        method.invoke(extension, stackName, uniqueProjectName)
    }
}