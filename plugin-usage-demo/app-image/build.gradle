/*
 * (c) Copyright 2023-2025 gradle-docker Contributors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * App-Image subproject - builds Docker image and runs integration tests.
 * 
 * This demonstrates how developers would use the gradle-docker plugin to:
 * - Build Docker images using the docker {} DSL (UC-6)  
 * - Test images using Docker Compose orchestration with dockerOrch {} DSL (UC-7)
 * - Use different lifecycle patterns (suite, class, method)
 * 
 * This subproject showcases realistic usage patterns developers would follow.
 */

plugins {
    id 'groovy'
    id 'com.kineticfire.gradle.gradle-docker' version '1.0.0'
}

group = 'com.kineticfire.gradle.docker.integration'
version = '1.0.0'

repositories {
    mavenLocal()
    mavenCentral()
}

// Configure source sets for testing
sourceSets {
    integrationTest {
        java.srcDir 'src/integrationTest/java'
        groovy.srcDir 'src/integrationTest/groovy'
        resources.srcDir 'src/integrationTest/resources'  
        compileClasspath += sourceSets.main.output
        runtimeClasspath += output + compileClasspath
    }
}

// Configure test configurations
configurations {
    integrationTestImplementation.extendsFrom implementation
    integrationTestRuntimeOnly.extendsFrom runtimeOnly
}

// Handle duplicate resources
tasks.withType(ProcessResources) {
    duplicatesStrategy = DuplicatesStrategy.WARN
}

dependencies {
    
    // Integration Test dependencies (Java/JUnit)  
    integrationTestImplementation platform(libs.junit.bom)
    integrationTestImplementation libs.junit.jupiter
    integrationTestImplementation libs.assertj.core
    integrationTestImplementation libs.jackson.databind
    integrationTestImplementation gradleTestKit()
    integrationTestImplementation libs.gradle.docker
    integrationTestRuntimeOnly libs.junit.platform.launcher
    
    // Integration Test dependencies (Groovy/Spock for registry tests)
    integrationTestImplementation platform(libs.spock.bom)
    integrationTestImplementation libs.spock.core
    integrationTestImplementation libs.spock.junit4
}

// Setup all-in-one 'docker' tasks:  build, tag, save, and publish
docker {
    images {

        // Define build, tag, save, and publish actions for the image 'timeServer'
        timeServer {

            // Define the Docker build context use to build the Docker image.  The build context is a directory whose
            // contents are used in the image build process.  The 'contextTask' takes a Gradle 'Copy' task, so one or
            // more files/directories may be included to create the build context.
            //
            // For debug purposes, inspect the Docker build context at 'build/docker-context/timeServer'.
            contextTask.set(tasks.register('prepareTimeServerContext', Copy) {
                group = 'docker'
                description = 'Prepare Docker build context for time server image'
                into layout.buildDirectory.dir('docker-context/timeServer')
                from('src/main/docker')
                dependsOn tasks.named('copyAppJar')
                dependsOn project(':app').tasks.jar
            })
            //dockerfile.set(file('src/main/docker/Dockerfile')) //todo
            tags = [
                "${version}",
                "latest"
            ]
            buildArgs = [
                'JAR_FILE': "app-${version}.jar",
                'BUILD_VERSION': version,
                'BUILD_TIME': new Date().format('yyyy-MM-dd HH:mm:ss')
            ]
            publish {
                to('basic') {
                    repository = 'localhost:25000/time-server-integration'
                    tags = ['latest']
                }
            }
        }

        // Build additional images by repeating the 'timeServer' configuration block template here
    }
}

// DEMONSTRATING UC-7: Project Developer Compose Orchestration  
//dockerOrch {
//    composeStacks {
//        smokeTest {
//            files.from('src/functionalTest/resources/compose/smoke-test.yml')
//            projectName = "smoke-${project.name}"
//            waitForHealthy {
//                services = ["time-server"]
//                timeoutSeconds = 30
//            }
//            logs {
//                writeTo = file("$buildDir/compose-logs/smokeTest")
//                tailLines = 100
//            }
//        }
//        integrationSuite {
//            files.from('src/integrationTest/resources/compose/integration-suite.yml')
//            projectName = "integration-suite-${project.name}"
//            waitForHealthy {
//                services = ["time-server"]
//                timeoutSeconds = 30
//            }
//            logs {
//                writeTo = file("$buildDir/compose-logs/integrationSuite")
//                tailLines = 200
//            }
//        }
//        integrationClass {
//            files.from('src/integrationTest/resources/compose/integration-class.yml')
//            projectName = "integration-class-${project.name}"
//            waitForHealthy {
//                services = ["time-server"]
//                timeoutSeconds = 45
//            }
//            logs {
//                writeTo = file("$buildDir/compose-logs/integrationClass")
//                tailLines = 200
//            }
//        }
//        integrationMethod {
//            files.from('src/integrationTest/resources/compose/integration-method.yml')
//            projectName = "integration-method-${project.name}"
//            waitForHealthy {
//                services = ["time-server"]
//                timeoutSeconds = 20
//            }
//            logs {
//                writeTo = file("$buildDir/compose-logs/integrationMethod")
//                tailLines = 100
//            }
//        }
//    }
//}

// Copy the app JAR to Docker context before building image
tasks.register('copyAppJar', Copy) {
    description = 'Copy app JAR to Docker build context'
    from project(':app').tasks.jar.outputs.files
    into 'src/main/docker'
    def projectVersion = version // Capture version during configuration time
    rename { "app-${projectVersion}.jar" }
}

//// JAR copying and Docker build dependencies are now handled through contextTask configuration
//
//// SMOKE TESTS: Quick validation using suite lifecycle (fastest)
//tasks.register('smokeTest', Test) {
//    description = 'Smoke tests with suite lifecycle - quick Docker image validation'
//    group = 'verification'
//    testClassesDirs = sourceSets.functionalTest.output.classesDirs
//    classpath = sourceSets.functionalTest.runtimeClasspath
//    useJUnitPlatform()
//
//    // DEMONSTRATE: Suite lifecycle - compose up once for all tests (fastest)
//    usesCompose stack: "smokeTest", lifecycle: "suite"
//    systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("smokeTest")
//
//    dependsOn 'dockerBuildTimeServer'
//}
//
//// INTEGRATION TESTS: Demonstrating different lifecycle patterns
//
//tasks.register('integrationTestSuite', Test) {
//    description = 'Integration tests with suite lifecycle - shared environment for performance'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/TimeServerSuiteLifecycleIT.class'
//
//    // DEMONSTRATE: Suite lifecycle - one compose up/down per test suite
//    usesCompose stack: "integrationSuite", lifecycle: "suite"
//    systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("integrationSuite")
//
//    dependsOn 'dockerBuildTimeServer'
//    shouldRunAfter 'smokeTest'
//}
//
//tasks.register('integrationTestClass', Test) {
//    description = 'Integration tests with class lifecycle - fresh environment per test class'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/TimeServerClassLifecycleIT.class'
//
//    // DEMONSTRATE: Class lifecycle - compose up/down per test class
//    usesCompose stack: "integrationClass", lifecycle: "class"
//    systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("integrationClass")
//
//    dependsOn 'dockerBuildTimeServer'
//    shouldRunAfter 'integrationTestSuite'
//}
//
//tasks.register('integrationTestMethod', Test) {
//    description = 'Integration tests with method lifecycle - maximum isolation (slowest)'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/TimeServerMethodLifecycleIT.class'
//
//    // DEMONSTRATE: Method lifecycle - compose up/down per test method (maximum isolation)
//    usesCompose stack: "integrationMethod", lifecycle: "method"
//    systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("integrationMethod")
//
//    dependsOn 'dockerBuildTimeServer'
//}
//
//tasks.register('integrationTestRegistry', Test) {
//    description = 'Integration tests for Docker registry publishing functionality'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/DockerRegistryPublishIntegrationIT.class'
//
//    dependsOn 'dockerBuildTimeServer'
//    shouldRunAfter 'integrationTestMethod'
//}
//
//// ENHANCED INTEGRATION TESTS: New comprehensive end-to-end tests
//
//tasks.register('integrationTestPluginTasks', Test) {
//    description = 'Integration tests for actual plugin Docker task execution'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/PluginDockerTaskExecutionIT.class'
//
//    shouldRunAfter 'integrationTestRegistry'
//}
//
//tasks.register('integrationTestComposeOrchestration', Test) {
//    description = 'Integration tests for plugin compose orchestration management'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/ComposeOrchestrationExecutionIT.class'
//
//    shouldRunAfter 'integrationTestPluginTasks'
//}
//
//tasks.register('integrationTestEndToEndWorkflows', Test) {
//    description = 'Integration tests for complete end-to-end workflows'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/EndToEndWorkflowIT.class'
//
//    shouldRunAfter 'integrationTestComposeOrchestration'
//}
//
//tasks.register('integrationTestEnhancedDSL', Test) {
//    description = 'Enhanced integration tests for plugin DSL with actual Docker execution'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/PluginDSLIntegrationIT.class'
//
//    shouldRunAfter 'integrationTestEndToEndWorkflows'
//}
//
//tasks.register('integrationTestErrorHandling', Test) {
//    description = 'Integration tests for error handling and edge cases'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/ErrorHandlingIntegrationIT.class'
//
//    shouldRunAfter 'integrationTestEnhancedDSL'
//}
//
//// COMPREHENSIVE INTEGRATION TEST SUITE
//
//tasks.register('integrationTestComprehensive', Test) {
//    description = 'Complete comprehensive integration test suite - all existing integration tests'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    // Include only the compatible integration tests that work with suite lifecycle
//    include '**/AdvancedDockerComposeIntegrationIT.class'
//    include '**/DockerOperationsIntegrationIT.class'
//    include '**/EnhancedComposeIntegrationIT.class'
//    include '**/StateFileConsumptionIT.class'
//    include '**/TimeServerSuiteLifecycleIT.class'
//
//    // COMPREHENSIVE TEST: Use suite lifecycle with integrationSuite stack for all tests
//    usesCompose stack: "integrationSuite", lifecycle: "suite"
//    systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("integrationSuite")
//
//    dependsOn 'dockerBuildTimeServer'
//}
//
//tasks.register('integrationTestClassLifecycleOnly', Test) {
//    description = 'Class lifecycle integration tests only'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/TimeServerClassLifecycleIT.class'
//
//    usesCompose stack: "integrationClass", lifecycle: "class"
//    systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("integrationClass")
//
//    dependsOn 'dockerBuildTimeServer'
//}
//
//tasks.register('integrationTestMethodLifecycleOnly', Test) {
//    description = 'Method lifecycle integration tests only'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/TimeServerMethodLifecycleIT.class'
//
//    usesCompose stack: "integrationMethod", lifecycle: "method"
//    systemProperty "COMPOSE_STATE_FILE", composeStateFileFor("integrationMethod")
//
//    dependsOn 'dockerBuildTimeServer'
//}
//
//tasks.register('integrationTestRegistryOnly', Test) {
//    description = 'Docker registry integration tests only - manages own Docker registries'
//    group = 'verification'
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//    useJUnitPlatform()
//    include '**/DockerRegistryPublishIntegrationIT.class'
//
//    dependsOn 'dockerBuildTimeServer'
//}
//
//// Update existing tasks to run after new comprehensive suite
//tasks.named('integrationTestSuite') {
//    shouldRunAfter 'integrationTestComprehensive'
//}
//
//tasks.named('integrationTestClass') {
//    shouldRunAfter 'integrationTestComprehensive'
//}
//
//tasks.named('integrationTestMethod') {
//    shouldRunAfter 'integrationTestComprehensive'
//}
//
//tasks.named('integrationTestRegistry') {
//    shouldRunAfter 'integrationTestComprehensive'
//}


